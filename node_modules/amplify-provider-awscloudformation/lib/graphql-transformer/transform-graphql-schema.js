"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildAPIProject = exports.getDirectiveDefinitions = exports.transformGraphQLSchema = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const import_global_1 = __importDefault(require("import-global"));
const graphql_1 = require("graphql");
const import_from_1 = __importDefault(require("import-from"));
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const graphql_model_transformer_1 = require("@aws-amplify/graphql-model-transformer");
const graphql_function_transformer_1 = require("@aws-amplify/graphql-function-transformer");
const graphql_http_transformer_1 = require("@aws-amplify/graphql-http-transformer");
const graphql_predictions_transformer_1 = require("@aws-amplify/graphql-predictions-transformer");
const graphql_index_transformer_1 = require("@aws-amplify/graphql-index-transformer");
const graphql_relational_transformer_1 = require("@aws-amplify/graphql-relational-transformer");
const graphql_searchable_transformer_1 = require("@aws-amplify/graphql-searchable-transformer");
const constants_1 = require("../constants");
const upload_appsync_files_1 = require("../upload-appsync-files");
const utils_1 = require("./utils");
const transform_config_1 = require("./transform-config");
const graphql_transformer_core_2 = require("graphql-transformer-core");
const amplify_cli_feature_flag_adapter_1 = require("../utils/amplify-cli-feature-flag-adapter");
const amplify_cli_core_1 = require("amplify-cli-core");
const API_CATEGORY = 'api';
const STORAGE_CATEGORY = 'storage';
const PARAMETERS_FILENAME = 'parameters.json';
const SCHEMA_FILENAME = 'schema.graphql';
const SCHEMA_DIR_NAME = 'schema';
const ROOT_APPSYNC_S3_KEY = 'amplify-appsync-files';
const S3_SERVICE_NAME = 'S3';
const TRANSFORM_CONFIG_FILE_NAME = `transform.conf.json`;
function warnOnAuth(context, map) {
    const a = true;
    const unAuthModelTypes = Object.keys(map).filter(type => !map[type].includes('auth') && map[type].includes('model'));
    if (unAuthModelTypes.length) {
        context.print.warning("\nThe following types do not have '@auth' enabled. Consider using @auth with @model");
        context.print.warning(unAuthModelTypes.map(type => `\t - ${type}`).join('\n'));
        context.print.info('Learn more about @auth here: https://docs.amplify.aws/cli/graphql-transformer/auth\n');
    }
}
function getTransformerFactory(context, resourceDir) {
    return async (options) => {
        const modelTransformer = new graphql_model_transformer_1.ModelTransformer();
        const indexTransformer = new graphql_index_transformer_1.IndexTransformer();
        const hasOneTransformer = new graphql_relational_transformer_1.HasOneTransformer();
        const transformerList = [
            modelTransformer,
            new graphql_function_transformer_1.FunctionTransformer(),
            new graphql_http_transformer_1.HttpTransformer(),
            new graphql_predictions_transformer_1.PredictionsTransformer(options === null || options === void 0 ? void 0 : options.storageConfig),
            new graphql_index_transformer_1.PrimaryKeyTransformer(),
            indexTransformer,
            new graphql_relational_transformer_1.BelongsToTransformer(),
            new graphql_relational_transformer_1.HasManyTransformer(),
            hasOneTransformer,
            new graphql_relational_transformer_1.ManyToManyTransformer(modelTransformer, indexTransformer, hasOneTransformer),
        ];
        if (options === null || options === void 0 ? void 0 : options.addSearchableTransformer) {
            transformerList.push(new graphql_searchable_transformer_1.SearchableModelTransformer());
        }
        const customTransformersConfig = await transform_config_1.loadProject(resourceDir);
        const customTransformers = (customTransformersConfig && customTransformersConfig.transformers ? customTransformersConfig.transformers : [])
            .map(transformer => {
            const fileUrlMatch = /^file:\/\/(.*)\s*$/m.exec(transformer);
            const modulePath = fileUrlMatch ? fileUrlMatch[1] : transformer;
            if (!modulePath) {
                throw new Error(`Invalid value specified for transformer: '${transformer}'`);
            }
            let importedModule;
            const tempModulePath = modulePath.toString();
            try {
                if (path_1.default.isAbsolute(tempModulePath)) {
                    importedModule = require(modulePath);
                }
                else {
                    const projectRootPath = context.amplify.pathManager.searchProjectRootPath();
                    const projectNodeModules = path_1.default.join(projectRootPath, 'node_modules');
                    try {
                        importedModule = import_from_1.default(projectNodeModules, modulePath);
                    }
                    catch (_) {
                    }
                    if (!importedModule) {
                        importedModule = import_global_1.default(modulePath);
                    }
                }
                return importedModule;
            }
            catch (error) {
                context.print.error(`Unable to import custom transformer module(${modulePath}).`);
                context.print.error(`You may fix this error by editing transformers at ${path_1.default.join(resourceDir, TRANSFORM_CONFIG_FILE_NAME)}`);
                throw error;
            }
        })
            .map(imported => {
            const CustomTransformer = imported.default;
            if (typeof CustomTransformer === 'function') {
                return new CustomTransformer();
            }
            else if (typeof CustomTransformer === 'object') {
                throw new Error("Custom Transformers' should implement TransformerProvider interface");
            }
            throw new Error("Custom Transformers' default export must be a function or an object");
        })
            .filter(customTransformer => customTransformer);
        if (customTransformers.length > 0) {
            transformerList.push(...customTransformers);
        }
        return transformerList;
    };
}
async function transformGraphQLSchema(context, options) {
    const backEndDir = context.amplify.pathManager.getBackendDirPath();
    const flags = context.parameters.options;
    if (flags['no-gql-override']) {
        return;
    }
    let { resourceDir, parameters } = options;
    const { forceCompile } = options;
    const { resourcesToBeCreated, resourcesToBeUpdated, allResources } = await context.amplify.getResourceStatus(API_CATEGORY);
    let resources = resourcesToBeCreated.concat(resourcesToBeUpdated);
    const resourceNeedCompile = allResources
        .filter(r => !resources.includes(r))
        .filter(r => {
        const buildDir = path_1.default.normalize(path_1.default.join(backEndDir, API_CATEGORY, r.resourceName, 'build'));
        return !fs_extra_1.default.existsSync(buildDir);
    });
    resources = resources.concat(resourceNeedCompile);
    if (forceCompile) {
        resources = resources.concat(allResources);
    }
    resources = resources.filter(resource => resource.service === 'AppSync');
    if (!resourceDir) {
        if (resources.length > 0) {
            const resource = resources[0];
            if (resource.providerPlugin !== constants_1.ProviderName) {
                return;
            }
            const { category, resourceName } = resource;
            resourceDir = path_1.default.normalize(path_1.default.join(backEndDir, category, resourceName));
        }
        else {
            return;
        }
    }
    let previouslyDeployedBackendDir = options.cloudBackendDirectory;
    if (!previouslyDeployedBackendDir) {
        if (resources.length > 0) {
            const resource = resources[0];
            if (resource.providerPlugin !== constants_1.ProviderName) {
                return;
            }
            const { category, resourceName } = resource;
            const cloudBackendRootDir = context.amplify.pathManager.getCurrentCloudBackendDirPath();
            previouslyDeployedBackendDir = path_1.default.normalize(path_1.default.join(cloudBackendRootDir, category, resourceName));
        }
    }
    const parametersFilePath = path_1.default.join(resourceDir, PARAMETERS_FILENAME);
    if (!parameters && fs_extra_1.default.existsSync(parametersFilePath)) {
        try {
            parameters = context.amplify.readJsonFile(parametersFilePath);
        }
        catch (e) {
            parameters = {};
        }
    }
    let { authConfig } = options;
    if (!authConfig) {
        if (resources[0].output.securityType) {
            authConfig = {
                defaultAuthentication: {
                    authenticationType: resources[0].output.securityType,
                },
                additionalAuthenticationProviders: [],
            };
        }
        else {
            ({ authConfig } = resources[0].output);
        }
    }
    const s3Resource = s3ResourceAlreadyExists(context);
    const storageConfig = s3Resource ? getBucketName(context, s3Resource, backEndDir) : undefined;
    const buildDir = path_1.default.normalize(path_1.default.join(resourceDir, 'build'));
    const schemaFilePath = path_1.default.normalize(path_1.default.join(resourceDir, SCHEMA_FILENAME));
    const schemaDirPath = path_1.default.normalize(path_1.default.join(resourceDir, SCHEMA_DIR_NAME));
    let deploymentRootKey = await getPreviousDeploymentRootKey(previouslyDeployedBackendDir);
    if (!deploymentRootKey) {
        const deploymentSubKey = await upload_appsync_files_1.hashDirectory(resourceDir);
        deploymentRootKey = `${ROOT_APPSYNC_S3_KEY}/${deploymentSubKey}`;
    }
    const projectBucket = options.dryRun ? 'fake-bucket' : getProjectBucket(context);
    const buildParameters = {
        ...parameters,
        S3DeploymentBucket: projectBucket,
        S3DeploymentRootKey: deploymentRootKey,
    };
    if (!options.dryRun) {
        fs_extra_1.default.ensureDirSync(buildDir);
    }
    const project = await graphql_transformer_core_2.loadProject(resourceDir);
    const lastDeployedProjectConfig = fs_extra_1.default.existsSync(previouslyDeployedBackendDir)
        ? await graphql_transformer_core_2.loadProject(previouslyDeployedBackendDir)
        : undefined;
    const directiveMap = graphql_transformer_core_1.collectDirectivesByTypeNames(project.schema);
    warnOnAuth(context, directiveMap.types);
    const transformerListFactory = getTransformerFactory(context, resourceDir);
    let searchableTransformerFlag = false;
    if (directiveMap.directives.includes('searchable')) {
        searchableTransformerFlag = true;
    }
    const buildConfig = {
        ...options,
        buildParameters,
        projectDirectory: resourceDir,
        transformersFactory: transformerListFactory,
        transformersFactoryArgs: { addSearchableTransformer: searchableTransformerFlag, storageConfig },
        rootStackFileName: 'cloudformation-template.json',
        currentCloudBackendDirectory: previouslyDeployedBackendDir,
        minify: options.minify,
        projectConfig: project,
        lastDeployedProjectConfig,
        authConfig,
    };
    const transformerOutput = await buildAPIProject(buildConfig);
    context.print.success(`\nGraphQL schema compiled successfully.\n\nEdit your schema at ${schemaFilePath} or \
place .graphql files in a directory at ${schemaDirPath}`);
    if (!options.dryRun) {
        amplify_cli_core_1.JSONUtilities.writeJson(parametersFilePath, parameters);
    }
    return transformerOutput;
}
exports.transformGraphQLSchema = transformGraphQLSchema;
function getProjectBucket(context) {
    const projectDetails = context.amplify.getProjectDetails();
    const projectBucket = projectDetails.amplifyMeta.providers ? projectDetails.amplifyMeta.providers[constants_1.ProviderName].DeploymentBucketName : '';
    return projectBucket;
}
async function getPreviousDeploymentRootKey(previouslyDeployedBackendDir) {
    let parameters;
    try {
        const parametersPath = path_1.default.join(previouslyDeployedBackendDir, `build/${PARAMETERS_FILENAME}`);
        const parametersExists = fs_extra_1.default.existsSync(parametersPath);
        if (parametersExists) {
            const parametersString = await fs_extra_1.default.readFile(parametersPath);
            parameters = JSON.parse(parametersString.toString());
        }
        return parameters.S3DeploymentRootKey;
    }
    catch (err) {
        return undefined;
    }
}
async function getDirectiveDefinitions(context, resourceDir) {
    const transformList = await getTransformerFactory(context, resourceDir)({ addSearchableTransformer: true });
    const appSynDirectives = graphql_transformer_core_1.getAppSyncServiceExtraDirectives();
    const transformDirectives = transformList
        .map(transformPluginInst => [transformPluginInst.directive, ...transformPluginInst.typeDefinitions].map(node => graphql_1.print(node)).join('\n'))
        .join('\n');
    return [appSynDirectives, transformDirectives].join('\n');
}
exports.getDirectiveDefinitions = getDirectiveDefinitions;
function s3ResourceAlreadyExists(context) {
    const { amplify } = context;
    try {
        let resourceName;
        const { amplifyMeta } = amplify.getProjectDetails();
        if (amplifyMeta[STORAGE_CATEGORY]) {
            const categoryResources = amplifyMeta[STORAGE_CATEGORY];
            Object.keys(categoryResources).forEach(resource => {
                if (categoryResources[resource].service === S3_SERVICE_NAME) {
                    resourceName = resource;
                }
            });
        }
        return resourceName;
    }
    catch (error) {
        if (error.name === 'UndeterminedEnvironmentError') {
            return undefined;
        }
        throw error;
    }
}
function getBucketName(context, s3ResourceName, backEndDir) {
    const { amplify } = context;
    const { amplifyMeta } = amplify.getProjectDetails();
    const stackName = amplifyMeta.providers.awscloudformation.StackName;
    const parametersFilePath = path_1.default.join(backEndDir, STORAGE_CATEGORY, s3ResourceName, PARAMETERS_FILENAME);
    const bucketParameters = context.amplify.readJsonFile(parametersFilePath);
    const bucketName = stackName.startsWith('amplify-')
        ? `${bucketParameters.bucketName}\${hash}-\${env}`
        : `${bucketParameters.bucketName}${s3ResourceName}-\${env}`;
    return { bucketName };
}
async function buildAPIProject(opts) {
    const builtProject = await _buildProject(opts);
    if (opts.projectDirectory && !opts.dryRun) {
        await utils_1.writeDeploymentToDisk(builtProject, path_1.default.join(opts.projectDirectory, 'build'), opts.rootStackFileName, opts.buildParameters, opts.minify);
    }
    return builtProject;
}
exports.buildAPIProject = buildAPIProject;
async function _buildProject(opts) {
    const userProjectConfig = opts.projectConfig;
    const stackMapping = userProjectConfig.config.StackMapping;
    const transformers = await opts.transformersFactory(opts.transformersFactoryArgs);
    const transform = new graphql_transformer_core_1.GraphQLTransform({
        transformers,
        stackMapping,
        transformConfig: userProjectConfig.config,
        authConfig: opts.authConfig,
        buildParameters: opts.buildParameters,
        stacks: opts.projectConfig.stacks || {},
        featureFlags: new amplify_cli_feature_flag_adapter_1.AmplifyCLIFeatureFlagAdapter(),
    });
    return transform.transform(userProjectConfig.schema.toString());
}
//# sourceMappingURL=transform-graphql-schema.js.map