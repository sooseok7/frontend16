"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.S3 = void 0;
const aws_js_1 = __importDefault(require("./aws.js"));
const lodash_1 = __importDefault(require("lodash"));
const providerName = require('../constants').ProviderName;
const configuration_manager_1 = require("../configuration-manager");
const fs_extra_1 = __importDefault(require("fs-extra"));
const ora_1 = __importDefault(require("ora"));
const paged_call_1 = require("./paged-call");
const minChunkSize = 5 * 1024 * 1024;
const { fileLogger } = require('../utils/aws-logger');
const logger = fileLogger('aws-s3');
class S3 {
    constructor(context, cred, options = {}) {
        this.getStringObjectFromBucket = async (bucketName, objectKey) => {
            try {
                const result = await this.s3
                    .getObject({
                    Bucket: bucketName,
                    Key: objectKey,
                })
                    .promise();
                return result.Body.toString();
            }
            catch (e) {
                if (e.statusCode === 404) {
                    return undefined;
                }
                throw e;
            }
        };
        this.context = context;
        this.s3 = new aws_js_1.default.S3({ ...cred, ...options });
    }
    static async getInstance(context, options = {}) {
        if (!S3.instance) {
            let cred = {};
            try {
                cred = await configuration_manager_1.loadConfiguration(context);
            }
            catch (e) {
            }
            S3.instance = new S3(context, cred, options);
        }
        return S3.instance;
    }
    populateUploadState() {
        const projectDetails = this.context.amplify.getProjectDetails();
        const { envName } = this.context.amplify.getEnvInfo();
        const projectBucket = projectDetails.amplifyMeta.providers
            ? projectDetails.amplifyMeta.providers[providerName].DeploymentBucketName
            : projectDetails.teamProviderInfo[envName][providerName].DeploymentBucketName;
        this.uploadState = {
            envName,
            s3Params: {
                Bucket: projectBucket,
            },
        };
    }
    attatchBucketToParams(s3Params, envName) {
        if (!s3Params.hasOwnProperty('Bucket')) {
            const projectDetails = this.context.amplify.getProjectDetails();
            if (!envName)
                envName = this.context.amplify.getEnvInfo().envName;
            const projectBucket = projectDetails.teamProviderInfo[envName][providerName].DeploymentBucketName;
            s3Params.Bucket = projectBucket;
        }
        return s3Params;
    }
    async uploadFile(s3Params, showSpinner = true) {
        if (this.uploadState === undefined) {
            this.populateUploadState();
        }
        let spinner = showSpinner ? ora_1.default('Uploading files...') : undefined;
        const augmentedS3Params = {
            ...s3Params,
            ...this.uploadState.s3Params,
        };
        const { Body, ...others } = augmentedS3Params;
        let uploadTask;
        try {
            showSpinner && spinner.start('Uploading files...');
            if ((s3Params.Body instanceof fs_extra_1.default.ReadStream && fs_extra_1.default.statSync(s3Params.Body.path).size > minChunkSize) ||
                (Buffer.isBuffer(s3Params.Body) && s3Params.Body.length > minChunkSize)) {
                logger('uploadFile.s3.upload', [others])();
                uploadTask = this.s3.upload(augmentedS3Params);
                uploadTask.on('httpUploadProgress', max => {
                    if (showSpinner)
                        spinner.text = `Uploading files...${Math.round((max.loaded / max.total) * 100)}%`;
                });
            }
            else {
                logger('uploadFile.s3.putObject', [others])();
                uploadTask = this.s3.putObject(augmentedS3Params);
            }
            await uploadTask.promise();
            return this.uploadState.s3Params.Bucket;
        }
        catch (ex) {
            logger('uploadFile.s3', [others])(ex);
            throw ex;
        }
        finally {
            showSpinner && spinner.stop();
        }
    }
    async getFile(s3Params, envName) {
        s3Params = this.attatchBucketToParams(s3Params, envName);
        const log = logger('s3.getFile', [s3Params]);
        try {
            log();
            const result = await this.s3.getObject(s3Params).promise();
            return result.Body;
        }
        catch (ex) {
            log(ex);
            throw ex;
        }
    }
    async createBucket(bucketName, throwIfExists = false) {
        const params = {
            Bucket: bucketName,
        };
        logger('createBucket.ifBucketExists', [bucketName])();
        if (!(await this.ifBucketExists(bucketName))) {
            this.context.print.warning('The specified S3 bucket to store the CloudFormation templates is not present. We are creating one for you....');
            this.context.print.warning(`Bucket name: ${bucketName}`);
            logger('createBucket.s3.createBucket', [params])();
            await this.s3.createBucket(params).promise();
            logger('createBucket.s3.waitFor', ['bucketExists', params])();
            await this.s3.waitFor('bucketExists', params).promise();
            this.context.print.success('S3 bucket successfully created');
            return bucketName;
        }
        else if (throwIfExists) {
            throw new Error(`Bucket ${bucketName} already exists`);
        }
    }
    async getAllObjectVersions(bucketName, options = null) {
        const result = await paged_call_1.pagedAWSCall(async (param, nextToken) => {
            const parmaWithNextToken = nextToken ? { ...param, ...nextToken } : param;
            logger('getAllObjectKey.s3.listObjectVersions', [parmaWithNextToken])();
            return await this.s3.listObjectVersions(parmaWithNextToken).promise();
        }, {
            Bucket: bucketName,
            ...options,
        }, (response) => { var _a; return (_a = response.Versions) === null || _a === void 0 ? void 0 : _a.map(({ Key, VersionId }) => ({ Key, VersionId })); }, async (response) => (response === null || response === void 0 ? void 0 : response.IsTruncated)
            ? { KeyMarker: response.NextKeyMarker, VersionIdMarker: response.NextVersionIdMarker, Prefix: response.Prefix }
            : undefined);
        return result;
    }
    async deleteDirectory(bucketName, dirPath) {
        logger('deleteDirectory.s3.getAllObjectVersions', [{ BucketName: bucketName }])();
        const allObjects = await this.getAllObjectVersions(bucketName, { Prefix: dirPath });
        const chunkedResult = lodash_1.default.chunk(allObjects, 1000);
        const chunkedResultLength = chunkedResult.length;
        for (let idx = 0; idx < chunkedResultLength; idx++) {
            logger(`deleteAllObjects.s3.deleteObjects (${idx} of ${chunkedResultLength})`, [{ Bucket: bucketName }])();
            await this.s3
                .deleteObjects({
                Bucket: bucketName,
                Delete: {
                    Objects: chunkedResult[idx],
                },
            })
                .promise();
        }
    }
    async deleteAllObjects(bucketName) {
        logger('deleteAllObjects.s3.getAllObjectVersions', [{ BucketName: bucketName }])();
        const allObjects = await this.getAllObjectVersions(bucketName);
        const chunkedResult = lodash_1.default.chunk(allObjects, 1000);
        const chunkedResultLength = chunkedResult.length;
        for (let idx = 0; idx < chunkedResultLength; idx++) {
            logger(`deleteAllObjects.s3.deleteObjects (${idx} of ${chunkedResultLength})`, [{ Bucket: bucketName }])();
            await this.s3
                .deleteObjects({
                Bucket: bucketName,
                Delete: {
                    Objects: chunkedResult[idx],
                },
            })
                .promise();
        }
    }
    async deleteS3Bucket(bucketName) {
        logger('deleteS3Bucket.s3.ifBucketExists', [{ BucketName: bucketName }])();
        if (await this.ifBucketExists(bucketName)) {
            logger('deleteS3Bucket.s3.deleteAllObjects', [{ BucketName: bucketName }])();
            await this.deleteAllObjects(bucketName);
            logger('deleteS3Bucket.s3.deleteBucket', [{ BucketName: bucketName }])();
            await this.s3.deleteBucket({ Bucket: bucketName }).promise();
        }
    }
    async emptyS3Bucket(bucketName) {
        if (await this.ifBucketExists(bucketName)) {
            await this.deleteAllObjects(bucketName);
        }
    }
    async ifBucketExists(bucketName) {
        try {
            logger('ifBucketExists.s3.headBucket', [{ BucketName: bucketName }])();
            await this.s3
                .headBucket({
                Bucket: bucketName,
            })
                .promise();
            return true;
        }
        catch (e) {
            logger('ifBucketExists.s3.headBucket', [{ BucketName: bucketName }])(e);
            if (e.statusCode === 404) {
                return false;
            }
            throw e;
        }
    }
}
exports.S3 = S3;
//# sourceMappingURL=aws-s3.js.map