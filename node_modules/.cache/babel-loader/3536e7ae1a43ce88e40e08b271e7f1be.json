{"ast":null,"code":"/*!\r\n * fragment-cache <https://github.com/jonschlinkert/fragment-cache>\r\n *\r\n * Copyright (c) 2016-2017, Jon Schlinkert.\r\n * Released under the MIT License.\r\n */\n'use strict';\n\nvar MapCache = require('map-cache');\n/**\r\n * Create a new `FragmentCache` with an optional object to use for `caches`.\r\n *\r\n * ```js\r\n * var fragment = new FragmentCache();\r\n * ```\r\n * @name FragmentCache\r\n * @param {String} `cacheName`\r\n * @return {Object} Returns the [map-cache][] instance.\r\n * @api public\r\n */\n\n\nfunction FragmentCache(caches) {\n  this.caches = caches || {};\n}\n/**\r\n * Prototype\r\n */\n\n\nFragmentCache.prototype = {\n  /**\r\n   * Get cache `name` from the `fragment.caches` object. Creates a new\r\n   * `MapCache` if it doesn't already exist.\r\n   *\r\n   * ```js\r\n   * var cache = fragment.cache('files');\r\n   * console.log(fragment.caches.hasOwnProperty('files'));\r\n   * //=> true\r\n   * ```\r\n   * @name .cache\r\n   * @param {String} `cacheName`\r\n   * @return {Object} Returns the [map-cache][] instance.\r\n   * @api public\r\n   */\n  cache: function (cacheName) {\n    return this.caches[cacheName] || (this.caches[cacheName] = new MapCache());\n  },\n\n  /**\r\n   * Set a value for property `key` on cache `name`\r\n   *\r\n   * ```js\r\n   * fragment.set('files', 'somefile.js', new File({path: 'somefile.js'}));\r\n   * ```\r\n   * @name .set\r\n   * @param {String} `name`\r\n   * @param {String} `key` Property name to set\r\n   * @param {any} `val` The value of `key`\r\n   * @return {Object} The cache instance for chaining\r\n   * @api public\r\n   */\n  set: function (cacheName, key, val) {\n    var cache = this.cache(cacheName);\n    cache.set(key, val);\n    return cache;\n  },\n\n  /**\r\n   * Returns true if a non-undefined value is set for `key` on fragment cache `name`.\r\n   *\r\n   * ```js\r\n   * var cache = fragment.cache('files');\r\n   * cache.set('somefile.js');\r\n   *\r\n   * console.log(cache.has('somefile.js'));\r\n   * //=> true\r\n   *\r\n   * console.log(cache.has('some-other-file.js'));\r\n   * //=> false\r\n   * ```\r\n   * @name .has\r\n   * @param {String} `name` Cache name\r\n   * @param {String} `key` Optionally specify a property to check for on cache `name`\r\n   * @return {Boolean}\r\n   * @api public\r\n   */\n  has: function (cacheName, key) {\n    return typeof this.get(cacheName, key) !== 'undefined';\n  },\n\n  /**\r\n   * Get `name`, or if specified, the value of `key`. Invokes the [cache]() method,\r\n   * so that cache `name` will be created it doesn't already exist. If `key` is not passed,\r\n   * the entire cache (`name`) is returned.\r\n   *\r\n   * ```js\r\n   * var Vinyl = require('vinyl');\r\n   * var cache = fragment.cache('files');\r\n   * cache.set('somefile.js', new Vinyl({path: 'somefile.js'}));\r\n   * console.log(cache.get('somefile.js'));\r\n   * //=> <File \"somefile.js\">\r\n   * ```\r\n   * @name .get\r\n   * @param {String} `name`\r\n   * @return {Object} Returns cache `name`, or the value of `key` if specified\r\n   * @api public\r\n   */\n  get: function (name, key) {\n    var cache = this.cache(name);\n\n    if (typeof key === 'string') {\n      return cache.get(key);\n    }\n\n    return cache;\n  }\n};\n/**\r\n * Expose `FragmentCache`\r\n */\n\nexports = module.exports = FragmentCache;","map":{"version":3,"sources":["C:/frontend/node_modules/fragment-cache/index.js"],"names":["MapCache","require","FragmentCache","caches","prototype","cache","cacheName","set","key","val","has","get","name","exports","module"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,IAAIA,QAAQ,GAAGC,OAAO,CAAC,WAAD,CAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASC,aAAT,CAAuBC,MAAvB,EAA+B;AAC7B,OAAKA,MAAL,GAAcA,MAAM,IAAI,EAAxB;AACD;AAED;AACA;AACA;;;AAEAD,aAAa,CAACE,SAAd,GAA0B;AAExB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEEC,EAAAA,KAAK,EAAE,UAASC,SAAT,EAAoB;AACzB,WAAO,KAAKH,MAAL,CAAYG,SAAZ,MAA2B,KAAKH,MAAL,CAAYG,SAAZ,IAAyB,IAAIN,QAAJ,EAApD,CAAP;AACD,GAnBuB;;AAqBxB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEEO,EAAAA,GAAG,EAAE,UAASD,SAAT,EAAoBE,GAApB,EAAyBC,GAAzB,EAA8B;AACjC,QAAIJ,KAAK,GAAG,KAAKA,KAAL,CAAWC,SAAX,CAAZ;AACAD,IAAAA,KAAK,CAACE,GAAN,CAAUC,GAAV,EAAeC,GAAf;AACA,WAAOJ,KAAP;AACD,GAvCuB;;AAyCxB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEEK,EAAAA,GAAG,EAAE,UAASJ,SAAT,EAAoBE,GAApB,EAAyB;AAC5B,WAAO,OAAO,KAAKG,GAAL,CAASL,SAAT,EAAoBE,GAApB,CAAP,KAAoC,WAA3C;AACD,GA/DuB;;AAiExB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEEG,EAAAA,GAAG,EAAE,UAASC,IAAT,EAAeJ,GAAf,EAAoB;AACvB,QAAIH,KAAK,GAAG,KAAKA,KAAL,CAAWO,IAAX,CAAZ;;AACA,QAAI,OAAOJ,GAAP,KAAe,QAAnB,EAA6B;AAC3B,aAAOH,KAAK,CAACM,GAAN,CAAUH,GAAV,CAAP;AACD;;AACD,WAAOH,KAAP;AACD;AAzFuB,CAA1B;AA4FA;AACA;AACA;;AAEAQ,OAAO,GAAGC,MAAM,CAACD,OAAP,GAAiBX,aAA3B","sourcesContent":["/*!\r\n * fragment-cache <https://github.com/jonschlinkert/fragment-cache>\r\n *\r\n * Copyright (c) 2016-2017, Jon Schlinkert.\r\n * Released under the MIT License.\r\n */\r\n\r\n'use strict';\r\n\r\nvar MapCache = require('map-cache');\r\n\r\n/**\r\n * Create a new `FragmentCache` with an optional object to use for `caches`.\r\n *\r\n * ```js\r\n * var fragment = new FragmentCache();\r\n * ```\r\n * @name FragmentCache\r\n * @param {String} `cacheName`\r\n * @return {Object} Returns the [map-cache][] instance.\r\n * @api public\r\n */\r\n\r\nfunction FragmentCache(caches) {\r\n  this.caches = caches || {};\r\n}\r\n\r\n/**\r\n * Prototype\r\n */\r\n\r\nFragmentCache.prototype = {\r\n\r\n  /**\r\n   * Get cache `name` from the `fragment.caches` object. Creates a new\r\n   * `MapCache` if it doesn't already exist.\r\n   *\r\n   * ```js\r\n   * var cache = fragment.cache('files');\r\n   * console.log(fragment.caches.hasOwnProperty('files'));\r\n   * //=> true\r\n   * ```\r\n   * @name .cache\r\n   * @param {String} `cacheName`\r\n   * @return {Object} Returns the [map-cache][] instance.\r\n   * @api public\r\n   */\r\n\r\n  cache: function(cacheName) {\r\n    return this.caches[cacheName] || (this.caches[cacheName] = new MapCache());\r\n  },\r\n\r\n  /**\r\n   * Set a value for property `key` on cache `name`\r\n   *\r\n   * ```js\r\n   * fragment.set('files', 'somefile.js', new File({path: 'somefile.js'}));\r\n   * ```\r\n   * @name .set\r\n   * @param {String} `name`\r\n   * @param {String} `key` Property name to set\r\n   * @param {any} `val` The value of `key`\r\n   * @return {Object} The cache instance for chaining\r\n   * @api public\r\n   */\r\n\r\n  set: function(cacheName, key, val) {\r\n    var cache = this.cache(cacheName);\r\n    cache.set(key, val);\r\n    return cache;\r\n  },\r\n\r\n  /**\r\n   * Returns true if a non-undefined value is set for `key` on fragment cache `name`.\r\n   *\r\n   * ```js\r\n   * var cache = fragment.cache('files');\r\n   * cache.set('somefile.js');\r\n   *\r\n   * console.log(cache.has('somefile.js'));\r\n   * //=> true\r\n   *\r\n   * console.log(cache.has('some-other-file.js'));\r\n   * //=> false\r\n   * ```\r\n   * @name .has\r\n   * @param {String} `name` Cache name\r\n   * @param {String} `key` Optionally specify a property to check for on cache `name`\r\n   * @return {Boolean}\r\n   * @api public\r\n   */\r\n\r\n  has: function(cacheName, key) {\r\n    return typeof this.get(cacheName, key) !== 'undefined';\r\n  },\r\n\r\n  /**\r\n   * Get `name`, or if specified, the value of `key`. Invokes the [cache]() method,\r\n   * so that cache `name` will be created it doesn't already exist. If `key` is not passed,\r\n   * the entire cache (`name`) is returned.\r\n   *\r\n   * ```js\r\n   * var Vinyl = require('vinyl');\r\n   * var cache = fragment.cache('files');\r\n   * cache.set('somefile.js', new Vinyl({path: 'somefile.js'}));\r\n   * console.log(cache.get('somefile.js'));\r\n   * //=> <File \"somefile.js\">\r\n   * ```\r\n   * @name .get\r\n   * @param {String} `name`\r\n   * @return {Object} Returns cache `name`, or the value of `key` if specified\r\n   * @api public\r\n   */\r\n\r\n  get: function(name, key) {\r\n    var cache = this.cache(name);\r\n    if (typeof key === 'string') {\r\n      return cache.get(key);\r\n    }\r\n    return cache;\r\n  }\r\n};\r\n\r\n/**\r\n * Expose `FragmentCache`\r\n */\r\n\r\nexports = module.exports = FragmentCache;\r\n"]},"metadata":{},"sourceType":"script"}