{"ast":null,"code":"'use strict';\n\nvar extglob = require('extglob');\n\nvar nanomatch = require('nanomatch');\n\nvar regexNot = require('regex-not');\n\nvar toRegex = require('to-regex');\n\nvar not;\n/**\r\n * Characters to use in negation regex (we want to \"not\" match\r\n * characters that are matched by other parsers)\r\n */\n\nvar TEXT = '([!@*?+]?\\\\(|\\\\)|\\\\[:?(?=.*?:?\\\\])|:?\\\\]|[*+?!^$.\\\\\\\\/])+';\n\nvar createNotRegex = function (opts) {\n  return not || (not = textRegex(TEXT));\n};\n/**\r\n * Parsers\r\n */\n\n\nmodule.exports = function (snapdragon) {\n  var parsers = snapdragon.parser.parsers; // register nanomatch parsers\n\n  snapdragon.use(nanomatch.parsers); // get references to some specific nanomatch parsers before they\n  // are overridden by the extglob and/or parsers\n\n  var escape = parsers.escape;\n  var slash = parsers.slash;\n  var qmark = parsers.qmark;\n  var plus = parsers.plus;\n  var star = parsers.star;\n  var dot = parsers.dot; // register extglob parsers\n\n  snapdragon.use(extglob.parsers); // custom micromatch parsers\n\n  snapdragon.parser.use(function () {\n    // override \"notRegex\" created in nanomatch parser\n    this.notRegex = /^\\!+(?!\\()/;\n  }) // reset the referenced parsers\n  .capture('escape', escape).capture('slash', slash).capture('qmark', qmark).capture('star', star).capture('plus', plus).capture('dot', dot)\n  /**\r\n   * Override `text` parser\r\n   */\n  .capture('text', function () {\n    if (this.isInside('bracket')) return;\n    var pos = this.position();\n    var m = this.match(createNotRegex(this.options));\n    if (!m || !m[0]) return; // escape regex boundary characters and simple brackets\n\n    var val = m[0].replace(/([[\\]^$])/g, '\\\\$1');\n    return pos({\n      type: 'text',\n      val: val\n    });\n  });\n};\n/**\r\n * Create text regex\r\n */\n\n\nfunction textRegex(pattern) {\n  var notStr = regexNot.create(pattern, {\n    contains: true,\n    strictClose: false\n  });\n  var prefix = '(?:[\\\\^]|\\\\\\\\|';\n  return toRegex(prefix + notStr + ')', {\n    strictClose: false\n  });\n}","map":{"version":3,"sources":["C:/frontend/node_modules/micromatch/lib/parsers.js"],"names":["extglob","require","nanomatch","regexNot","toRegex","not","TEXT","createNotRegex","opts","textRegex","module","exports","snapdragon","parsers","parser","use","escape","slash","qmark","plus","star","dot","notRegex","capture","isInside","pos","position","m","match","options","val","replace","type","pattern","notStr","create","contains","strictClose","prefix"],"mappings":"AAAA;;AAEA,IAAIA,OAAO,GAAGC,OAAO,CAAC,SAAD,CAArB;;AACA,IAAIC,SAAS,GAAGD,OAAO,CAAC,WAAD,CAAvB;;AACA,IAAIE,QAAQ,GAAGF,OAAO,CAAC,WAAD,CAAtB;;AACA,IAAIG,OAAO,GAAGH,OAAO,CAAC,UAAD,CAArB;;AACA,IAAII,GAAJ;AAEA;AACA;AACA;AACA;;AAEA,IAAIC,IAAI,GAAG,2DAAX;;AACA,IAAIC,cAAc,GAAG,UAASC,IAAT,EAAe;AAClC,SAAOH,GAAG,KAAKA,GAAG,GAAGI,SAAS,CAACH,IAAD,CAApB,CAAV;AACD,CAFD;AAIA;AACA;AACA;;;AAEAI,MAAM,CAACC,OAAP,GAAiB,UAASC,UAAT,EAAqB;AACpC,MAAIC,OAAO,GAAGD,UAAU,CAACE,MAAX,CAAkBD,OAAhC,CADoC,CAGpC;;AACAD,EAAAA,UAAU,CAACG,GAAX,CAAeb,SAAS,CAACW,OAAzB,EAJoC,CAMpC;AACA;;AACA,MAAIG,MAAM,GAAGH,OAAO,CAACG,MAArB;AACA,MAAIC,KAAK,GAAGJ,OAAO,CAACI,KAApB;AACA,MAAIC,KAAK,GAAGL,OAAO,CAACK,KAApB;AACA,MAAIC,IAAI,GAAGN,OAAO,CAACM,IAAnB;AACA,MAAIC,IAAI,GAAGP,OAAO,CAACO,IAAnB;AACA,MAAIC,GAAG,GAAGR,OAAO,CAACQ,GAAlB,CAboC,CAepC;;AACAT,EAAAA,UAAU,CAACG,GAAX,CAAef,OAAO,CAACa,OAAvB,EAhBoC,CAkBpC;;AACAD,EAAAA,UAAU,CAACE,MAAX,CACGC,GADH,CACO,YAAW;AACd;AACA,SAAKO,QAAL,GAAgB,YAAhB;AACD,GAJH,EAKE;AALF,GAMGC,OANH,CAMW,QANX,EAMqBP,MANrB,EAOGO,OAPH,CAOW,OAPX,EAOoBN,KAPpB,EAQGM,OARH,CAQW,OARX,EAQoBL,KARpB,EASGK,OATH,CASW,MATX,EASmBH,IATnB,EAUGG,OAVH,CAUW,MAVX,EAUmBJ,IAVnB,EAWGI,OAXH,CAWW,KAXX,EAWkBF,GAXlB;AAaE;AACJ;AACA;AAfE,GAiBGE,OAjBH,CAiBW,MAjBX,EAiBmB,YAAW;AAC1B,QAAI,KAAKC,QAAL,CAAc,SAAd,CAAJ,EAA8B;AAC9B,QAAIC,GAAG,GAAG,KAAKC,QAAL,EAAV;AACA,QAAIC,CAAC,GAAG,KAAKC,KAAL,CAAWrB,cAAc,CAAC,KAAKsB,OAAN,CAAzB,CAAR;AACA,QAAI,CAACF,CAAD,IAAM,CAACA,CAAC,CAAC,CAAD,CAAZ,EAAiB,OAJS,CAM1B;;AACA,QAAIG,GAAG,GAAGH,CAAC,CAAC,CAAD,CAAD,CAAKI,OAAL,CAAa,YAAb,EAA2B,MAA3B,CAAV;AAEA,WAAON,GAAG,CAAC;AACTO,MAAAA,IAAI,EAAE,MADG;AAETF,MAAAA,GAAG,EAAEA;AAFI,KAAD,CAAV;AAID,GA9BH;AA+BD,CAlDD;AAoDA;AACA;AACA;;;AAEA,SAASrB,SAAT,CAAmBwB,OAAnB,EAA4B;AAC1B,MAAIC,MAAM,GAAG/B,QAAQ,CAACgC,MAAT,CAAgBF,OAAhB,EAAyB;AAACG,IAAAA,QAAQ,EAAE,IAAX;AAAiBC,IAAAA,WAAW,EAAE;AAA9B,GAAzB,CAAb;AACA,MAAIC,MAAM,GAAG,gBAAb;AACA,SAAOlC,OAAO,CAACkC,MAAM,GAAGJ,MAAT,GAAkB,GAAnB,EAAwB;AAACG,IAAAA,WAAW,EAAE;AAAd,GAAxB,CAAd;AACD","sourcesContent":["'use strict';\r\n\r\nvar extglob = require('extglob');\r\nvar nanomatch = require('nanomatch');\r\nvar regexNot = require('regex-not');\r\nvar toRegex = require('to-regex');\r\nvar not;\r\n\r\n/**\r\n * Characters to use in negation regex (we want to \"not\" match\r\n * characters that are matched by other parsers)\r\n */\r\n\r\nvar TEXT = '([!@*?+]?\\\\(|\\\\)|\\\\[:?(?=.*?:?\\\\])|:?\\\\]|[*+?!^$.\\\\\\\\/])+';\r\nvar createNotRegex = function(opts) {\r\n  return not || (not = textRegex(TEXT));\r\n};\r\n\r\n/**\r\n * Parsers\r\n */\r\n\r\nmodule.exports = function(snapdragon) {\r\n  var parsers = snapdragon.parser.parsers;\r\n\r\n  // register nanomatch parsers\r\n  snapdragon.use(nanomatch.parsers);\r\n\r\n  // get references to some specific nanomatch parsers before they\r\n  // are overridden by the extglob and/or parsers\r\n  var escape = parsers.escape;\r\n  var slash = parsers.slash;\r\n  var qmark = parsers.qmark;\r\n  var plus = parsers.plus;\r\n  var star = parsers.star;\r\n  var dot = parsers.dot;\r\n\r\n  // register extglob parsers\r\n  snapdragon.use(extglob.parsers);\r\n\r\n  // custom micromatch parsers\r\n  snapdragon.parser\r\n    .use(function() {\r\n      // override \"notRegex\" created in nanomatch parser\r\n      this.notRegex = /^\\!+(?!\\()/;\r\n    })\r\n    // reset the referenced parsers\r\n    .capture('escape', escape)\r\n    .capture('slash', slash)\r\n    .capture('qmark', qmark)\r\n    .capture('star', star)\r\n    .capture('plus', plus)\r\n    .capture('dot', dot)\r\n\r\n    /**\r\n     * Override `text` parser\r\n     */\r\n\r\n    .capture('text', function() {\r\n      if (this.isInside('bracket')) return;\r\n      var pos = this.position();\r\n      var m = this.match(createNotRegex(this.options));\r\n      if (!m || !m[0]) return;\r\n\r\n      // escape regex boundary characters and simple brackets\r\n      var val = m[0].replace(/([[\\]^$])/g, '\\\\$1');\r\n\r\n      return pos({\r\n        type: 'text',\r\n        val: val\r\n      });\r\n    });\r\n};\r\n\r\n/**\r\n * Create text regex\r\n */\r\n\r\nfunction textRegex(pattern) {\r\n  var notStr = regexNot.create(pattern, {contains: true, strictClose: false});\r\n  var prefix = '(?:[\\\\^]|\\\\\\\\|';\r\n  return toRegex(prefix + notStr + ')', {strictClose: false});\r\n}\r\n"]},"metadata":{},"sourceType":"script"}