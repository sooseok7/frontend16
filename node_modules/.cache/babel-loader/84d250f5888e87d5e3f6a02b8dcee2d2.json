{"ast":null,"code":"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\nvar pathModule = require('path');\n\nvar isWindows = process.platform === 'win32';\n\nvar fs = require('fs'); // JavaScript implementation of realpath, ported from node pre-v6\n\n\nvar DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);\n\nfunction rethrow() {\n  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and\n  // is fairly slow to generate.\n  var callback;\n\n  if (DEBUG) {\n    var backtrace = new Error();\n    callback = debugCallback;\n  } else callback = missingCallback;\n\n  return callback;\n\n  function debugCallback(err) {\n    if (err) {\n      backtrace.message = err.message;\n      err = backtrace;\n      missingCallback(err);\n    }\n  }\n\n  function missingCallback(err) {\n    if (err) {\n      if (process.throwDeprecation) throw err; // Forgot a callback but don't know where? Use NODE_DEBUG=fs\n      else if (!process.noDeprecation) {\n        var msg = 'fs: missing callback ' + (err.stack || err.message);\n        if (process.traceDeprecation) console.trace(msg);else console.error(msg);\n      }\n    }\n  }\n}\n\nfunction maybeCallback(cb) {\n  return typeof cb === 'function' ? cb : rethrow();\n}\n\nvar normalize = pathModule.normalize; // Regexp that finds the next partion of a (partial) path\n// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']\n\nif (isWindows) {\n  var nextPartRe = /(.*?)(?:[\\/\\\\]+|$)/g;\n} else {\n  var nextPartRe = /(.*?)(?:[\\/]+|$)/g;\n} // Regex to find the device root, including trailing slash. E.g. 'c:\\\\'.\n\n\nif (isWindows) {\n  var splitRootRe = /^(?:[a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/][^\\\\\\/]+)?[\\\\\\/]*/;\n} else {\n  var splitRootRe = /^[\\/]*/;\n}\n\nexports.realpathSync = function realpathSync(p, cache) {\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return cache[p];\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {}; // current character position in p\n\n  var pos; // the partial path so far, including a trailing slash if any\n\n  var current; // the partial path without a trailing slash (except when pointing at a root)\n\n  var base; // the partial path scanned in the previous round, with slash\n\n  var previous;\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = ''; // On windows, check that the root exists. On unix there is no need.\n\n    if (isWindows && !knownHard[base]) {\n      fs.lstatSync(base);\n      knownHard[base] = true;\n    }\n  } // walk down the path, swapping out linked pathparts for their real\n  // values\n  // NB: p.length changes.\n\n\n  while (pos < p.length) {\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex; // continue if not a symlink\n\n    if (knownHard[base] || cache && cache[base] === base) {\n      continue;\n    }\n\n    var resolvedLink;\n\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // some known symbolic link.  no need to stat again.\n      resolvedLink = cache[base];\n    } else {\n      var stat = fs.lstatSync(base);\n\n      if (!stat.isSymbolicLink()) {\n        knownHard[base] = true;\n        if (cache) cache[base] = base;\n        continue;\n      } // read the link if it wasn't read before\n      // dev/ino always return 0 on windows, so skip the check.\n\n\n      var linkTarget = null;\n\n      if (!isWindows) {\n        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n\n        if (seenLinks.hasOwnProperty(id)) {\n          linkTarget = seenLinks[id];\n        }\n      }\n\n      if (linkTarget === null) {\n        fs.statSync(base);\n        linkTarget = fs.readlinkSync(base);\n      }\n\n      resolvedLink = pathModule.resolve(previous, linkTarget); // track this, if given a cache.\n\n      if (cache) cache[base] = resolvedLink;\n      if (!isWindows) seenLinks[id] = linkTarget;\n    } // resolve the link, then start over\n\n\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n\n  if (cache) cache[original] = p;\n  return p;\n};\n\nexports.realpath = function realpath(p, cache, cb) {\n  if (typeof cb !== 'function') {\n    cb = maybeCallback(cache);\n    cache = null;\n  } // make p is absolute\n\n\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return process.nextTick(cb.bind(null, null, cache[p]));\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {}; // current character position in p\n\n  var pos; // the partial path so far, including a trailing slash if any\n\n  var current; // the partial path without a trailing slash (except when pointing at a root)\n\n  var base; // the partial path scanned in the previous round, with slash\n\n  var previous;\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = ''; // On windows, check that the root exists. On unix there is no need.\n\n    if (isWindows && !knownHard[base]) {\n      fs.lstat(base, function (err) {\n        if (err) return cb(err);\n        knownHard[base] = true;\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  } // walk down the path, swapping out linked pathparts for their real\n  // values\n\n\n  function LOOP() {\n    // stop if scanned past end of path\n    if (pos >= p.length) {\n      if (cache) cache[original] = p;\n      return cb(null, p);\n    } // find the next part\n\n\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex; // continue if not a symlink\n\n    if (knownHard[base] || cache && cache[base] === base) {\n      return process.nextTick(LOOP);\n    }\n\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // known symbolic link.  no need to stat again.\n      return gotResolvedLink(cache[base]);\n    }\n\n    return fs.lstat(base, gotStat);\n  }\n\n  function gotStat(err, stat) {\n    if (err) return cb(err); // if not a symlink, skip to the next path part\n\n    if (!stat.isSymbolicLink()) {\n      knownHard[base] = true;\n      if (cache) cache[base] = base;\n      return process.nextTick(LOOP);\n    } // stat & read the link if not read before\n    // call gotTarget as soon as the link target is known\n    // dev/ino always return 0 on windows, so skip the check.\n\n\n    if (!isWindows) {\n      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n\n      if (seenLinks.hasOwnProperty(id)) {\n        return gotTarget(null, seenLinks[id], base);\n      }\n    }\n\n    fs.stat(base, function (err) {\n      if (err) return cb(err);\n      fs.readlink(base, function (err, target) {\n        if (!isWindows) seenLinks[id] = target;\n        gotTarget(err, target);\n      });\n    });\n  }\n\n  function gotTarget(err, target, base) {\n    if (err) return cb(err);\n    var resolvedLink = pathModule.resolve(previous, target);\n    if (cache) cache[base] = resolvedLink;\n    gotResolvedLink(resolvedLink);\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n};","map":{"version":3,"sources":["C:/frontend/node_modules/fs.realpath/old.js"],"names":["pathModule","require","isWindows","process","platform","fs","DEBUG","env","NODE_DEBUG","test","rethrow","callback","backtrace","Error","debugCallback","missingCallback","err","message","throwDeprecation","noDeprecation","msg","stack","traceDeprecation","console","trace","error","maybeCallback","cb","normalize","nextPartRe","splitRootRe","exports","realpathSync","p","cache","resolve","Object","prototype","hasOwnProperty","call","original","seenLinks","knownHard","pos","current","base","previous","start","m","exec","length","lstatSync","lastIndex","result","resolvedLink","stat","isSymbolicLink","linkTarget","id","dev","toString","ino","statSync","readlinkSync","slice","realpath","nextTick","bind","lstat","LOOP","gotResolvedLink","gotStat","gotTarget","readlink","target"],"mappings":"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","sourcesContent":["// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\nvar pathModule = require('path');\r\nvar isWindows = process.platform === 'win32';\r\nvar fs = require('fs');\r\n\r\n// JavaScript implementation of realpath, ported from node pre-v6\r\n\r\nvar DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);\r\n\r\nfunction rethrow() {\r\n  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and\r\n  // is fairly slow to generate.\r\n  var callback;\r\n  if (DEBUG) {\r\n    var backtrace = new Error;\r\n    callback = debugCallback;\r\n  } else\r\n    callback = missingCallback;\r\n\r\n  return callback;\r\n\r\n  function debugCallback(err) {\r\n    if (err) {\r\n      backtrace.message = err.message;\r\n      err = backtrace;\r\n      missingCallback(err);\r\n    }\r\n  }\r\n\r\n  function missingCallback(err) {\r\n    if (err) {\r\n      if (process.throwDeprecation)\r\n        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs\r\n      else if (!process.noDeprecation) {\r\n        var msg = 'fs: missing callback ' + (err.stack || err.message);\r\n        if (process.traceDeprecation)\r\n          console.trace(msg);\r\n        else\r\n          console.error(msg);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction maybeCallback(cb) {\r\n  return typeof cb === 'function' ? cb : rethrow();\r\n}\r\n\r\nvar normalize = pathModule.normalize;\r\n\r\n// Regexp that finds the next partion of a (partial) path\r\n// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']\r\nif (isWindows) {\r\n  var nextPartRe = /(.*?)(?:[\\/\\\\]+|$)/g;\r\n} else {\r\n  var nextPartRe = /(.*?)(?:[\\/]+|$)/g;\r\n}\r\n\r\n// Regex to find the device root, including trailing slash. E.g. 'c:\\\\'.\r\nif (isWindows) {\r\n  var splitRootRe = /^(?:[a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/][^\\\\\\/]+)?[\\\\\\/]*/;\r\n} else {\r\n  var splitRootRe = /^[\\/]*/;\r\n}\r\n\r\nexports.realpathSync = function realpathSync(p, cache) {\r\n  // make p is absolute\r\n  p = pathModule.resolve(p);\r\n\r\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\r\n    return cache[p];\r\n  }\r\n\r\n  var original = p,\r\n      seenLinks = {},\r\n      knownHard = {};\r\n\r\n  // current character position in p\r\n  var pos;\r\n  // the partial path so far, including a trailing slash if any\r\n  var current;\r\n  // the partial path without a trailing slash (except when pointing at a root)\r\n  var base;\r\n  // the partial path scanned in the previous round, with slash\r\n  var previous;\r\n\r\n  start();\r\n\r\n  function start() {\r\n    // Skip over roots\r\n    var m = splitRootRe.exec(p);\r\n    pos = m[0].length;\r\n    current = m[0];\r\n    base = m[0];\r\n    previous = '';\r\n\r\n    // On windows, check that the root exists. On unix there is no need.\r\n    if (isWindows && !knownHard[base]) {\r\n      fs.lstatSync(base);\r\n      knownHard[base] = true;\r\n    }\r\n  }\r\n\r\n  // walk down the path, swapping out linked pathparts for their real\r\n  // values\r\n  // NB: p.length changes.\r\n  while (pos < p.length) {\r\n    // find the next part\r\n    nextPartRe.lastIndex = pos;\r\n    var result = nextPartRe.exec(p);\r\n    previous = current;\r\n    current += result[0];\r\n    base = previous + result[1];\r\n    pos = nextPartRe.lastIndex;\r\n\r\n    // continue if not a symlink\r\n    if (knownHard[base] || (cache && cache[base] === base)) {\r\n      continue;\r\n    }\r\n\r\n    var resolvedLink;\r\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\r\n      // some known symbolic link.  no need to stat again.\r\n      resolvedLink = cache[base];\r\n    } else {\r\n      var stat = fs.lstatSync(base);\r\n      if (!stat.isSymbolicLink()) {\r\n        knownHard[base] = true;\r\n        if (cache) cache[base] = base;\r\n        continue;\r\n      }\r\n\r\n      // read the link if it wasn't read before\r\n      // dev/ino always return 0 on windows, so skip the check.\r\n      var linkTarget = null;\r\n      if (!isWindows) {\r\n        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\r\n        if (seenLinks.hasOwnProperty(id)) {\r\n          linkTarget = seenLinks[id];\r\n        }\r\n      }\r\n      if (linkTarget === null) {\r\n        fs.statSync(base);\r\n        linkTarget = fs.readlinkSync(base);\r\n      }\r\n      resolvedLink = pathModule.resolve(previous, linkTarget);\r\n      // track this, if given a cache.\r\n      if (cache) cache[base] = resolvedLink;\r\n      if (!isWindows) seenLinks[id] = linkTarget;\r\n    }\r\n\r\n    // resolve the link, then start over\r\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\r\n    start();\r\n  }\r\n\r\n  if (cache) cache[original] = p;\r\n\r\n  return p;\r\n};\r\n\r\n\r\nexports.realpath = function realpath(p, cache, cb) {\r\n  if (typeof cb !== 'function') {\r\n    cb = maybeCallback(cache);\r\n    cache = null;\r\n  }\r\n\r\n  // make p is absolute\r\n  p = pathModule.resolve(p);\r\n\r\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\r\n    return process.nextTick(cb.bind(null, null, cache[p]));\r\n  }\r\n\r\n  var original = p,\r\n      seenLinks = {},\r\n      knownHard = {};\r\n\r\n  // current character position in p\r\n  var pos;\r\n  // the partial path so far, including a trailing slash if any\r\n  var current;\r\n  // the partial path without a trailing slash (except when pointing at a root)\r\n  var base;\r\n  // the partial path scanned in the previous round, with slash\r\n  var previous;\r\n\r\n  start();\r\n\r\n  function start() {\r\n    // Skip over roots\r\n    var m = splitRootRe.exec(p);\r\n    pos = m[0].length;\r\n    current = m[0];\r\n    base = m[0];\r\n    previous = '';\r\n\r\n    // On windows, check that the root exists. On unix there is no need.\r\n    if (isWindows && !knownHard[base]) {\r\n      fs.lstat(base, function(err) {\r\n        if (err) return cb(err);\r\n        knownHard[base] = true;\r\n        LOOP();\r\n      });\r\n    } else {\r\n      process.nextTick(LOOP);\r\n    }\r\n  }\r\n\r\n  // walk down the path, swapping out linked pathparts for their real\r\n  // values\r\n  function LOOP() {\r\n    // stop if scanned past end of path\r\n    if (pos >= p.length) {\r\n      if (cache) cache[original] = p;\r\n      return cb(null, p);\r\n    }\r\n\r\n    // find the next part\r\n    nextPartRe.lastIndex = pos;\r\n    var result = nextPartRe.exec(p);\r\n    previous = current;\r\n    current += result[0];\r\n    base = previous + result[1];\r\n    pos = nextPartRe.lastIndex;\r\n\r\n    // continue if not a symlink\r\n    if (knownHard[base] || (cache && cache[base] === base)) {\r\n      return process.nextTick(LOOP);\r\n    }\r\n\r\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\r\n      // known symbolic link.  no need to stat again.\r\n      return gotResolvedLink(cache[base]);\r\n    }\r\n\r\n    return fs.lstat(base, gotStat);\r\n  }\r\n\r\n  function gotStat(err, stat) {\r\n    if (err) return cb(err);\r\n\r\n    // if not a symlink, skip to the next path part\r\n    if (!stat.isSymbolicLink()) {\r\n      knownHard[base] = true;\r\n      if (cache) cache[base] = base;\r\n      return process.nextTick(LOOP);\r\n    }\r\n\r\n    // stat & read the link if not read before\r\n    // call gotTarget as soon as the link target is known\r\n    // dev/ino always return 0 on windows, so skip the check.\r\n    if (!isWindows) {\r\n      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\r\n      if (seenLinks.hasOwnProperty(id)) {\r\n        return gotTarget(null, seenLinks[id], base);\r\n      }\r\n    }\r\n    fs.stat(base, function(err) {\r\n      if (err) return cb(err);\r\n\r\n      fs.readlink(base, function(err, target) {\r\n        if (!isWindows) seenLinks[id] = target;\r\n        gotTarget(err, target);\r\n      });\r\n    });\r\n  }\r\n\r\n  function gotTarget(err, target, base) {\r\n    if (err) return cb(err);\r\n\r\n    var resolvedLink = pathModule.resolve(previous, target);\r\n    if (cache) cache[base] = resolvedLink;\r\n    gotResolvedLink(resolvedLink);\r\n  }\r\n\r\n  function gotResolvedLink(resolvedLink) {\r\n    // resolve the link, then start over\r\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\r\n    start();\r\n  }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}