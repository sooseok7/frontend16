{"ast":null,"code":"'use strict';\n\nvar extend = require('extend-shallow');\n\nvar safe = require('safe-regex');\n/**\r\n * The main export is a function that takes a `pattern` string and an `options` object.\r\n *\r\n * ```js\r\n & var not = require('regex-not');\r\n & console.log(not('foo'));\r\n & //=> /^(?:(?!^(?:foo)$).)*$/\r\n * ```\r\n *\r\n * @param {String} `pattern`\r\n * @param {Object} `options`\r\n * @return {RegExp} Converts the given `pattern` to a regex using the specified `options`.\r\n * @api public\r\n */\n\n\nfunction toRegex(pattern, options) {\n  return new RegExp(toRegex.create(pattern, options));\n}\n/**\r\n * Create a regex-compatible string from the given `pattern` and `options`.\r\n *\r\n * ```js\r\n & var not = require('regex-not');\r\n & console.log(not.create('foo'));\r\n & //=> '^(?:(?!^(?:foo)$).)*$'\r\n * ```\r\n * @param {String} `pattern`\r\n * @param {Object} `options`\r\n * @return {String}\r\n * @api public\r\n */\n\n\ntoRegex.create = function (pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected a string');\n  }\n\n  var opts = extend({}, options);\n\n  if (opts.contains === true) {\n    opts.strictNegate = false;\n  }\n\n  var open = opts.strictOpen !== false ? '^' : '';\n  var close = opts.strictClose !== false ? '$' : '';\n  var endChar = opts.endChar ? opts.endChar : '+';\n  var str = pattern;\n\n  if (opts.strictNegate === false) {\n    str = '(?:(?!(?:' + pattern + ')).)' + endChar;\n  } else {\n    str = '(?:(?!^(?:' + pattern + ')$).)' + endChar;\n  }\n\n  var res = open + str + close;\n\n  if (opts.safe === true && safe(res) === false) {\n    throw new Error('potentially unsafe regular expression: ' + res);\n  }\n\n  return res;\n};\n/**\r\n * Expose `toRegex`\r\n */\n\n\nmodule.exports = toRegex;","map":{"version":3,"sources":["C:/frontend/node_modules/regex-not/index.js"],"names":["extend","require","safe","toRegex","pattern","options","RegExp","create","TypeError","opts","contains","strictNegate","open","strictOpen","close","strictClose","endChar","str","res","Error","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,gBAAD,CAApB;;AACA,IAAIC,IAAI,GAAGD,OAAO,CAAC,YAAD,CAAlB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASE,OAAT,CAAiBC,OAAjB,EAA0BC,OAA1B,EAAmC;AACjC,SAAO,IAAIC,MAAJ,CAAWH,OAAO,CAACI,MAAR,CAAeH,OAAf,EAAwBC,OAAxB,CAAX,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAF,OAAO,CAACI,MAAR,GAAiB,UAASH,OAAT,EAAkBC,OAAlB,EAA2B;AAC1C,MAAI,OAAOD,OAAP,KAAmB,QAAvB,EAAiC;AAC/B,UAAM,IAAII,SAAJ,CAAc,mBAAd,CAAN;AACD;;AAED,MAAIC,IAAI,GAAGT,MAAM,CAAC,EAAD,EAAKK,OAAL,CAAjB;;AACA,MAAII,IAAI,CAACC,QAAL,KAAkB,IAAtB,EAA4B;AAC1BD,IAAAA,IAAI,CAACE,YAAL,GAAoB,KAApB;AACD;;AAED,MAAIC,IAAI,GAAGH,IAAI,CAACI,UAAL,KAAoB,KAApB,GAA4B,GAA5B,GAAkC,EAA7C;AACA,MAAIC,KAAK,GAAGL,IAAI,CAACM,WAAL,KAAqB,KAArB,GAA6B,GAA7B,GAAmC,EAA/C;AACA,MAAIC,OAAO,GAAGP,IAAI,CAACO,OAAL,GAAeP,IAAI,CAACO,OAApB,GAA8B,GAA5C;AACA,MAAIC,GAAG,GAAGb,OAAV;;AAEA,MAAIK,IAAI,CAACE,YAAL,KAAsB,KAA1B,EAAiC;AAC/BM,IAAAA,GAAG,GAAG,cAAcb,OAAd,GAAwB,MAAxB,GAAiCY,OAAvC;AACD,GAFD,MAEO;AACLC,IAAAA,GAAG,GAAG,eAAeb,OAAf,GAAyB,OAAzB,GAAmCY,OAAzC;AACD;;AAED,MAAIE,GAAG,GAAGN,IAAI,GAAGK,GAAP,GAAaH,KAAvB;;AACA,MAAIL,IAAI,CAACP,IAAL,KAAc,IAAd,IAAsBA,IAAI,CAACgB,GAAD,CAAJ,KAAc,KAAxC,EAA+C;AAC7C,UAAM,IAAIC,KAAJ,CAAU,4CAA4CD,GAAtD,CAAN;AACD;;AAED,SAAOA,GAAP;AACD,CA3BD;AA6BA;AACA;AACA;;;AAEAE,MAAM,CAACC,OAAP,GAAiBlB,OAAjB","sourcesContent":["'use strict';\r\n\r\nvar extend = require('extend-shallow');\r\nvar safe = require('safe-regex');\r\n\r\n/**\r\n * The main export is a function that takes a `pattern` string and an `options` object.\r\n *\r\n * ```js\r\n & var not = require('regex-not');\r\n & console.log(not('foo'));\r\n & //=> /^(?:(?!^(?:foo)$).)*$/\r\n * ```\r\n *\r\n * @param {String} `pattern`\r\n * @param {Object} `options`\r\n * @return {RegExp} Converts the given `pattern` to a regex using the specified `options`.\r\n * @api public\r\n */\r\n\r\nfunction toRegex(pattern, options) {\r\n  return new RegExp(toRegex.create(pattern, options));\r\n}\r\n\r\n/**\r\n * Create a regex-compatible string from the given `pattern` and `options`.\r\n *\r\n * ```js\r\n & var not = require('regex-not');\r\n & console.log(not.create('foo'));\r\n & //=> '^(?:(?!^(?:foo)$).)*$'\r\n * ```\r\n * @param {String} `pattern`\r\n * @param {Object} `options`\r\n * @return {String}\r\n * @api public\r\n */\r\n\r\ntoRegex.create = function(pattern, options) {\r\n  if (typeof pattern !== 'string') {\r\n    throw new TypeError('expected a string');\r\n  }\r\n\r\n  var opts = extend({}, options);\r\n  if (opts.contains === true) {\r\n    opts.strictNegate = false;\r\n  }\r\n\r\n  var open = opts.strictOpen !== false ? '^' : '';\r\n  var close = opts.strictClose !== false ? '$' : '';\r\n  var endChar = opts.endChar ? opts.endChar : '+';\r\n  var str = pattern;\r\n\r\n  if (opts.strictNegate === false) {\r\n    str = '(?:(?!(?:' + pattern + ')).)' + endChar;\r\n  } else {\r\n    str = '(?:(?!^(?:' + pattern + ')$).)' + endChar;\r\n  }\r\n\r\n  var res = open + str + close;\r\n  if (opts.safe === true && safe(res) === false) {\r\n    throw new Error('potentially unsafe regular expression: ' + res);\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\n/**\r\n * Expose `toRegex`\r\n */\r\n\r\nmodule.exports = toRegex;\r\n"]},"metadata":{},"sourceType":"script"}