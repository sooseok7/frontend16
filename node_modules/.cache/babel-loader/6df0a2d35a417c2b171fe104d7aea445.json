{"ast":null,"code":"'use strict';\n\nvar isObject = require('isobject');\n\nvar define = require('define-property');\n\nvar utils = require('snapdragon-util');\n\nvar ownNames;\n/**\r\n * Create a new AST `Node` with the given `val` and `type`.\r\n *\r\n * ```js\r\n * var node = new Node('*', 'Star');\r\n * var node = new Node({type: 'star', val: '*'});\r\n * ```\r\n * @name Node\r\n * @param {String|Object} `val` Pass a matched substring, or an object to merge onto the node.\r\n * @param {String} `type` The node type to use when `val` is a string.\r\n * @return {Object} node instance\r\n * @api public\r\n */\n\nfunction Node(val, type, parent) {\n  if (typeof type !== 'string') {\n    parent = type;\n    type = null;\n  }\n\n  define(this, 'parent', parent);\n  define(this, 'isNode', true);\n  define(this, 'expect', null);\n\n  if (typeof type !== 'string' && isObject(val)) {\n    lazyKeys();\n    var keys = Object.keys(val);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (ownNames.indexOf(key) === -1) {\n        this[key] = val[key];\n      }\n    }\n  } else {\n    this.type = type;\n    this.val = val;\n  }\n}\n/**\r\n * Returns true if the given value is a node.\r\n *\r\n * ```js\r\n * var Node = require('snapdragon-node');\r\n * var node = new Node({type: 'foo'});\r\n * console.log(Node.isNode(node)); //=> true\r\n * console.log(Node.isNode({})); //=> false\r\n * ```\r\n * @param {Object} `node`\r\n * @returns {Boolean}\r\n * @api public\r\n */\n\n\nNode.isNode = function (node) {\n  return utils.isNode(node);\n};\n/**\r\n * Define a non-enumberable property on the node instance.\r\n * Useful for adding properties that shouldn't be extended\r\n * or visible during debugging.\r\n *\r\n * ```js\r\n * var node = new Node();\r\n * node.define('foo', 'something non-enumerable');\r\n * ```\r\n * @param {String} `name`\r\n * @param {any} `val`\r\n * @return {Object} returns the node instance\r\n * @api public\r\n */\n\n\nNode.prototype.define = function (name, val) {\n  define(this, name, val);\n  return this;\n};\n/**\r\n * Returns true if `node.val` is an empty string, or `node.nodes` does\r\n * not contain any non-empty text nodes.\r\n *\r\n * ```js\r\n * var node = new Node({type: 'text'});\r\n * node.isEmpty(); //=> true\r\n * node.val = 'foo';\r\n * node.isEmpty(); //=> false\r\n * ```\r\n * @param {Function} `fn` (optional) Filter function that is called on `node` and/or child nodes. `isEmpty` will return false immediately when the filter function returns false on any nodes.\r\n * @return {Boolean}\r\n * @api public\r\n */\n\n\nNode.prototype.isEmpty = function (fn) {\n  return utils.isEmpty(this, fn);\n};\n/**\r\n * Given node `foo` and node `bar`, push node `bar` onto `foo.nodes`, and\r\n * set `foo` as `bar.parent`.\r\n *\r\n * ```js\r\n * var foo = new Node({type: 'foo'});\r\n * var bar = new Node({type: 'bar'});\r\n * foo.push(bar);\r\n * ```\r\n * @param {Object} `node`\r\n * @return {Number} Returns the length of `node.nodes`\r\n * @api public\r\n */\n\n\nNode.prototype.push = function (node) {\n  assert(Node.isNode(node), 'expected node to be an instance of Node');\n  define(node, 'parent', this);\n  this.nodes = this.nodes || [];\n  return this.nodes.push(node);\n};\n/**\r\n * Given node `foo` and node `bar`, unshift node `bar` onto `foo.nodes`, and\r\n * set `foo` as `bar.parent`.\r\n *\r\n * ```js\r\n * var foo = new Node({type: 'foo'});\r\n * var bar = new Node({type: 'bar'});\r\n * foo.unshift(bar);\r\n * ```\r\n * @param {Object} `node`\r\n * @return {Number} Returns the length of `node.nodes`\r\n * @api public\r\n */\n\n\nNode.prototype.unshift = function (node) {\n  assert(Node.isNode(node), 'expected node to be an instance of Node');\n  define(node, 'parent', this);\n  this.nodes = this.nodes || [];\n  return this.nodes.unshift(node);\n};\n/**\r\n * Pop a node from `node.nodes`.\r\n *\r\n * ```js\r\n * var node = new Node({type: 'foo'});\r\n * node.push(new Node({type: 'a'}));\r\n * node.push(new Node({type: 'b'}));\r\n * node.push(new Node({type: 'c'}));\r\n * node.push(new Node({type: 'd'}));\r\n * console.log(node.nodes.length);\r\n * //=> 4\r\n * node.pop();\r\n * console.log(node.nodes.length);\r\n * //=> 3\r\n * ```\r\n * @return {Number} Returns the popped `node`\r\n * @api public\r\n */\n\n\nNode.prototype.pop = function () {\n  return this.nodes && this.nodes.pop();\n};\n/**\r\n * Shift a node from `node.nodes`.\r\n *\r\n * ```js\r\n * var node = new Node({type: 'foo'});\r\n * node.push(new Node({type: 'a'}));\r\n * node.push(new Node({type: 'b'}));\r\n * node.push(new Node({type: 'c'}));\r\n * node.push(new Node({type: 'd'}));\r\n * console.log(node.nodes.length);\r\n * //=> 4\r\n * node.shift();\r\n * console.log(node.nodes.length);\r\n * //=> 3\r\n * ```\r\n * @return {Object} Returns the shifted `node`\r\n * @api public\r\n */\n\n\nNode.prototype.shift = function () {\n  return this.nodes && this.nodes.shift();\n};\n/**\r\n * Remove `node` from `node.nodes`.\r\n *\r\n * ```js\r\n * node.remove(childNode);\r\n * ```\r\n * @param {Object} `node`\r\n * @return {Object} Returns the removed node.\r\n * @api public\r\n */\n\n\nNode.prototype.remove = function (node) {\n  assert(Node.isNode(node), 'expected node to be an instance of Node');\n  this.nodes = this.nodes || [];\n  var idx = node.index;\n\n  if (idx !== -1) {\n    node.index = -1;\n    return this.nodes.splice(idx, 1);\n  }\n\n  return null;\n};\n/**\r\n * Get the first child node from `node.nodes` that matches the given `type`.\r\n * If `type` is a number, the child node at that index is returned.\r\n *\r\n * ```js\r\n * var child = node.find(1); //<= index of the node to get\r\n * var child = node.find('foo'); //<= node.type of a child node\r\n * var child = node.find(/^(foo|bar)$/); //<= regex to match node.type\r\n * var child = node.find(['foo', 'bar']); //<= array of node.type(s)\r\n * ```\r\n * @param {String} `type`\r\n * @return {Object} Returns a child node or undefined.\r\n * @api public\r\n */\n\n\nNode.prototype.find = function (type) {\n  return utils.findNode(this.nodes, type);\n};\n/**\r\n * Return true if the node is the given `type`.\r\n *\r\n * ```js\r\n * var node = new Node({type: 'bar'});\r\n * cosole.log(node.isType('foo'));          // false\r\n * cosole.log(node.isType(/^(foo|bar)$/));  // true\r\n * cosole.log(node.isType(['foo', 'bar'])); // true\r\n * ```\r\n * @param {String} `type`\r\n * @return {Boolean}\r\n * @api public\r\n */\n\n\nNode.prototype.isType = function (type) {\n  return utils.isType(this, type);\n};\n/**\r\n * Return true if the `node.nodes` has the given `type`.\r\n *\r\n * ```js\r\n * var foo = new Node({type: 'foo'});\r\n * var bar = new Node({type: 'bar'});\r\n * foo.push(bar);\r\n *\r\n * cosole.log(foo.hasType('qux'));          // false\r\n * cosole.log(foo.hasType(/^(qux|bar)$/));  // true\r\n * cosole.log(foo.hasType(['qux', 'bar'])); // true\r\n * ```\r\n * @param {String} `type`\r\n * @return {Boolean}\r\n * @api public\r\n */\n\n\nNode.prototype.hasType = function (type) {\n  return utils.hasType(this, type);\n};\n/**\r\n * Get the siblings array, or `null` if it doesn't exist.\r\n *\r\n * ```js\r\n * var foo = new Node({type: 'foo'});\r\n * var bar = new Node({type: 'bar'});\r\n * var baz = new Node({type: 'baz'});\r\n * foo.push(bar);\r\n * foo.push(baz);\r\n *\r\n * console.log(bar.siblings.length) // 2\r\n * console.log(baz.siblings.length) // 2\r\n * ```\r\n * @return {Array}\r\n * @api public\r\n */\n\n\nObject.defineProperty(Node.prototype, 'siblings', {\n  set: function () {\n    throw new Error('node.siblings is a getter and cannot be defined');\n  },\n  get: function () {\n    return this.parent ? this.parent.nodes : null;\n  }\n});\n/**\r\n * Get the node's current index from `node.parent.nodes`.\r\n * This should always be correct, even when the parent adds nodes.\r\n *\r\n * ```js\r\n * var foo = new Node({type: 'foo'});\r\n * var bar = new Node({type: 'bar'});\r\n * var baz = new Node({type: 'baz'});\r\n * var qux = new Node({type: 'qux'});\r\n * foo.push(bar);\r\n * foo.push(baz);\r\n * foo.unshift(qux);\r\n *\r\n * console.log(bar.index) // 1\r\n * console.log(baz.index) // 2\r\n * console.log(qux.index) // 0\r\n * ```\r\n * @return {Number}\r\n * @api public\r\n */\n\nObject.defineProperty(Node.prototype, 'index', {\n  set: function (index) {\n    define(this, 'idx', index);\n  },\n  get: function () {\n    if (!Array.isArray(this.siblings)) {\n      return -1;\n    }\n\n    var tok = this.idx !== -1 ? this.siblings[this.idx] : null;\n\n    if (tok !== this) {\n      this.idx = this.siblings.indexOf(this);\n    }\n\n    return this.idx;\n  }\n});\n/**\r\n * Get the previous node from the siblings array or `null`.\r\n *\r\n * ```js\r\n * var foo = new Node({type: 'foo'});\r\n * var bar = new Node({type: 'bar'});\r\n * var baz = new Node({type: 'baz'});\r\n * foo.push(bar);\r\n * foo.push(baz);\r\n *\r\n * console.log(baz.prev.type) // 'bar'\r\n * ```\r\n * @return {Object}\r\n * @api public\r\n */\n\nObject.defineProperty(Node.prototype, 'prev', {\n  set: function () {\n    throw new Error('node.prev is a getter and cannot be defined');\n  },\n  get: function () {\n    if (Array.isArray(this.siblings)) {\n      return this.siblings[this.index - 1] || this.parent.prev;\n    }\n\n    return null;\n  }\n});\n/**\r\n * Get the siblings array, or `null` if it doesn't exist.\r\n *\r\n * ```js\r\n * var foo = new Node({type: 'foo'});\r\n * var bar = new Node({type: 'bar'});\r\n * var baz = new Node({type: 'baz'});\r\n * foo.push(bar);\r\n * foo.push(baz);\r\n *\r\n * console.log(bar.siblings.length) // 2\r\n * console.log(baz.siblings.length) // 2\r\n * ```\r\n * @return {Object}\r\n * @api public\r\n */\n\nObject.defineProperty(Node.prototype, 'next', {\n  set: function () {\n    throw new Error('node.next is a getter and cannot be defined');\n  },\n  get: function () {\n    if (Array.isArray(this.siblings)) {\n      return this.siblings[this.index + 1] || this.parent.next;\n    }\n\n    return null;\n  }\n});\n/**\r\n * Get the first node from `node.nodes`.\r\n *\r\n * ```js\r\n * var foo = new Node({type: 'foo'});\r\n * var bar = new Node({type: 'bar'});\r\n * var baz = new Node({type: 'baz'});\r\n * var qux = new Node({type: 'qux'});\r\n * foo.push(bar);\r\n * foo.push(baz);\r\n * foo.push(qux);\r\n *\r\n * console.log(foo.first.type) // 'bar'\r\n * ```\r\n * @return {Object} The first node, or undefiend\r\n * @api public\r\n */\n\nObject.defineProperty(Node.prototype, 'first', {\n  get: function () {\n    return this.nodes ? this.nodes[0] : null;\n  }\n});\n/**\r\n * Get the last node from `node.nodes`.\r\n *\r\n * ```js\r\n * var foo = new Node({type: 'foo'});\r\n * var bar = new Node({type: 'bar'});\r\n * var baz = new Node({type: 'baz'});\r\n * var qux = new Node({type: 'qux'});\r\n * foo.push(bar);\r\n * foo.push(baz);\r\n * foo.push(qux);\r\n *\r\n * console.log(foo.last.type) // 'qux'\r\n * ```\r\n * @return {Object} The last node, or undefiend\r\n * @api public\r\n */\n\nObject.defineProperty(Node.prototype, 'last', {\n  get: function () {\n    return this.nodes ? utils.last(this.nodes) : null;\n  }\n});\n/**\r\n * Get the last node from `node.nodes`.\r\n *\r\n * ```js\r\n * var foo = new Node({type: 'foo'});\r\n * var bar = new Node({type: 'bar'});\r\n * var baz = new Node({type: 'baz'});\r\n * var qux = new Node({type: 'qux'});\r\n * foo.push(bar);\r\n * foo.push(baz);\r\n * foo.push(qux);\r\n *\r\n * console.log(foo.last.type) // 'qux'\r\n * ```\r\n * @return {Object} The last node, or undefiend\r\n * @api public\r\n */\n\nObject.defineProperty(Node.prototype, 'scope', {\n  get: function () {\n    if (this.isScope !== true) {\n      return this.parent ? this.parent.scope : this;\n    }\n\n    return this;\n  }\n});\n/**\r\n * Get own property names from Node prototype, but only the\r\n * first time `Node` is instantiated\r\n */\n\nfunction lazyKeys() {\n  if (!ownNames) {\n    ownNames = Object.getOwnPropertyNames(Node.prototype);\n  }\n}\n/**\r\n * Simplified assertion. Throws an error is `val` is falsey.\r\n */\n\n\nfunction assert(val, message) {\n  if (!val) throw new Error(message);\n}\n/**\r\n * Expose `Node`\r\n */\n\n\nexports = module.exports = Node;","map":{"version":3,"sources":["C:/frontend/node_modules/snapdragon-node/index.js"],"names":["isObject","require","define","utils","ownNames","Node","val","type","parent","lazyKeys","keys","Object","i","length","key","indexOf","isNode","node","prototype","name","isEmpty","fn","push","assert","nodes","unshift","pop","shift","remove","idx","index","splice","find","findNode","isType","hasType","defineProperty","set","Error","get","Array","isArray","siblings","tok","prev","next","last","isScope","scope","getOwnPropertyNames","message","exports","module"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nvar isObject = require('isobject');\r\nvar define = require('define-property');\r\nvar utils = require('snapdragon-util');\r\nvar ownNames;\r\n\r\n/**\r\n * Create a new AST `Node` with the given `val` and `type`.\r\n *\r\n * ```js\r\n * var node = new Node('*', 'Star');\r\n * var node = new Node({type: 'star', val: '*'});\r\n * ```\r\n * @name Node\r\n * @param {String|Object} `val` Pass a matched substring, or an object to merge onto the node.\r\n * @param {String} `type` The node type to use when `val` is a string.\r\n * @return {Object} node instance\r\n * @api public\r\n */\r\n\r\nfunction Node(val, type, parent) {\r\n  if (typeof type !== 'string') {\r\n    parent = type;\r\n    type = null;\r\n  }\r\n\r\n  define(this, 'parent', parent);\r\n  define(this, 'isNode', true);\r\n  define(this, 'expect', null);\r\n\r\n  if (typeof type !== 'string' && isObject(val)) {\r\n    lazyKeys();\r\n    var keys = Object.keys(val);\r\n    for (var i = 0; i < keys.length; i++) {\r\n      var key = keys[i];\r\n      if (ownNames.indexOf(key) === -1) {\r\n        this[key] = val[key];\r\n      }\r\n    }\r\n  } else {\r\n    this.type = type;\r\n    this.val = val;\r\n  }\r\n}\r\n\r\n/**\r\n * Returns true if the given value is a node.\r\n *\r\n * ```js\r\n * var Node = require('snapdragon-node');\r\n * var node = new Node({type: 'foo'});\r\n * console.log(Node.isNode(node)); //=> true\r\n * console.log(Node.isNode({})); //=> false\r\n * ```\r\n * @param {Object} `node`\r\n * @returns {Boolean}\r\n * @api public\r\n */\r\n\r\nNode.isNode = function(node) {\r\n  return utils.isNode(node);\r\n};\r\n\r\n/**\r\n * Define a non-enumberable property on the node instance.\r\n * Useful for adding properties that shouldn't be extended\r\n * or visible during debugging.\r\n *\r\n * ```js\r\n * var node = new Node();\r\n * node.define('foo', 'something non-enumerable');\r\n * ```\r\n * @param {String} `name`\r\n * @param {any} `val`\r\n * @return {Object} returns the node instance\r\n * @api public\r\n */\r\n\r\nNode.prototype.define = function(name, val) {\r\n  define(this, name, val);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Returns true if `node.val` is an empty string, or `node.nodes` does\r\n * not contain any non-empty text nodes.\r\n *\r\n * ```js\r\n * var node = new Node({type: 'text'});\r\n * node.isEmpty(); //=> true\r\n * node.val = 'foo';\r\n * node.isEmpty(); //=> false\r\n * ```\r\n * @param {Function} `fn` (optional) Filter function that is called on `node` and/or child nodes. `isEmpty` will return false immediately when the filter function returns false on any nodes.\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nNode.prototype.isEmpty = function(fn) {\r\n  return utils.isEmpty(this, fn);\r\n};\r\n\r\n/**\r\n * Given node `foo` and node `bar`, push node `bar` onto `foo.nodes`, and\r\n * set `foo` as `bar.parent`.\r\n *\r\n * ```js\r\n * var foo = new Node({type: 'foo'});\r\n * var bar = new Node({type: 'bar'});\r\n * foo.push(bar);\r\n * ```\r\n * @param {Object} `node`\r\n * @return {Number} Returns the length of `node.nodes`\r\n * @api public\r\n */\r\n\r\nNode.prototype.push = function(node) {\r\n  assert(Node.isNode(node), 'expected node to be an instance of Node');\r\n  define(node, 'parent', this);\r\n\r\n  this.nodes = this.nodes || [];\r\n  return this.nodes.push(node);\r\n};\r\n\r\n/**\r\n * Given node `foo` and node `bar`, unshift node `bar` onto `foo.nodes`, and\r\n * set `foo` as `bar.parent`.\r\n *\r\n * ```js\r\n * var foo = new Node({type: 'foo'});\r\n * var bar = new Node({type: 'bar'});\r\n * foo.unshift(bar);\r\n * ```\r\n * @param {Object} `node`\r\n * @return {Number} Returns the length of `node.nodes`\r\n * @api public\r\n */\r\n\r\nNode.prototype.unshift = function(node) {\r\n  assert(Node.isNode(node), 'expected node to be an instance of Node');\r\n  define(node, 'parent', this);\r\n\r\n  this.nodes = this.nodes || [];\r\n  return this.nodes.unshift(node);\r\n};\r\n\r\n/**\r\n * Pop a node from `node.nodes`.\r\n *\r\n * ```js\r\n * var node = new Node({type: 'foo'});\r\n * node.push(new Node({type: 'a'}));\r\n * node.push(new Node({type: 'b'}));\r\n * node.push(new Node({type: 'c'}));\r\n * node.push(new Node({type: 'd'}));\r\n * console.log(node.nodes.length);\r\n * //=> 4\r\n * node.pop();\r\n * console.log(node.nodes.length);\r\n * //=> 3\r\n * ```\r\n * @return {Number} Returns the popped `node`\r\n * @api public\r\n */\r\n\r\nNode.prototype.pop = function() {\r\n  return this.nodes && this.nodes.pop();\r\n};\r\n\r\n/**\r\n * Shift a node from `node.nodes`.\r\n *\r\n * ```js\r\n * var node = new Node({type: 'foo'});\r\n * node.push(new Node({type: 'a'}));\r\n * node.push(new Node({type: 'b'}));\r\n * node.push(new Node({type: 'c'}));\r\n * node.push(new Node({type: 'd'}));\r\n * console.log(node.nodes.length);\r\n * //=> 4\r\n * node.shift();\r\n * console.log(node.nodes.length);\r\n * //=> 3\r\n * ```\r\n * @return {Object} Returns the shifted `node`\r\n * @api public\r\n */\r\n\r\nNode.prototype.shift = function() {\r\n  return this.nodes && this.nodes.shift();\r\n};\r\n\r\n/**\r\n * Remove `node` from `node.nodes`.\r\n *\r\n * ```js\r\n * node.remove(childNode);\r\n * ```\r\n * @param {Object} `node`\r\n * @return {Object} Returns the removed node.\r\n * @api public\r\n */\r\n\r\nNode.prototype.remove = function(node) {\r\n  assert(Node.isNode(node), 'expected node to be an instance of Node');\r\n  this.nodes = this.nodes || [];\r\n  var idx = node.index;\r\n  if (idx !== -1) {\r\n    node.index = -1;\r\n    return this.nodes.splice(idx, 1);\r\n  }\r\n  return null;\r\n};\r\n\r\n/**\r\n * Get the first child node from `node.nodes` that matches the given `type`.\r\n * If `type` is a number, the child node at that index is returned.\r\n *\r\n * ```js\r\n * var child = node.find(1); //<= index of the node to get\r\n * var child = node.find('foo'); //<= node.type of a child node\r\n * var child = node.find(/^(foo|bar)$/); //<= regex to match node.type\r\n * var child = node.find(['foo', 'bar']); //<= array of node.type(s)\r\n * ```\r\n * @param {String} `type`\r\n * @return {Object} Returns a child node or undefined.\r\n * @api public\r\n */\r\n\r\nNode.prototype.find = function(type) {\r\n  return utils.findNode(this.nodes, type);\r\n};\r\n\r\n/**\r\n * Return true if the node is the given `type`.\r\n *\r\n * ```js\r\n * var node = new Node({type: 'bar'});\r\n * cosole.log(node.isType('foo'));          // false\r\n * cosole.log(node.isType(/^(foo|bar)$/));  // true\r\n * cosole.log(node.isType(['foo', 'bar'])); // true\r\n * ```\r\n * @param {String} `type`\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nNode.prototype.isType = function(type) {\r\n  return utils.isType(this, type);\r\n};\r\n\r\n/**\r\n * Return true if the `node.nodes` has the given `type`.\r\n *\r\n * ```js\r\n * var foo = new Node({type: 'foo'});\r\n * var bar = new Node({type: 'bar'});\r\n * foo.push(bar);\r\n *\r\n * cosole.log(foo.hasType('qux'));          // false\r\n * cosole.log(foo.hasType(/^(qux|bar)$/));  // true\r\n * cosole.log(foo.hasType(['qux', 'bar'])); // true\r\n * ```\r\n * @param {String} `type`\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nNode.prototype.hasType = function(type) {\r\n  return utils.hasType(this, type);\r\n};\r\n\r\n/**\r\n * Get the siblings array, or `null` if it doesn't exist.\r\n *\r\n * ```js\r\n * var foo = new Node({type: 'foo'});\r\n * var bar = new Node({type: 'bar'});\r\n * var baz = new Node({type: 'baz'});\r\n * foo.push(bar);\r\n * foo.push(baz);\r\n *\r\n * console.log(bar.siblings.length) // 2\r\n * console.log(baz.siblings.length) // 2\r\n * ```\r\n * @return {Array}\r\n * @api public\r\n */\r\n\r\nObject.defineProperty(Node.prototype, 'siblings', {\r\n  set: function() {\r\n    throw new Error('node.siblings is a getter and cannot be defined');\r\n  },\r\n  get: function() {\r\n    return this.parent ? this.parent.nodes : null;\r\n  }\r\n});\r\n\r\n/**\r\n * Get the node's current index from `node.parent.nodes`.\r\n * This should always be correct, even when the parent adds nodes.\r\n *\r\n * ```js\r\n * var foo = new Node({type: 'foo'});\r\n * var bar = new Node({type: 'bar'});\r\n * var baz = new Node({type: 'baz'});\r\n * var qux = new Node({type: 'qux'});\r\n * foo.push(bar);\r\n * foo.push(baz);\r\n * foo.unshift(qux);\r\n *\r\n * console.log(bar.index) // 1\r\n * console.log(baz.index) // 2\r\n * console.log(qux.index) // 0\r\n * ```\r\n * @return {Number}\r\n * @api public\r\n */\r\n\r\nObject.defineProperty(Node.prototype, 'index', {\r\n  set: function(index) {\r\n    define(this, 'idx', index);\r\n  },\r\n  get: function() {\r\n    if (!Array.isArray(this.siblings)) {\r\n      return -1;\r\n    }\r\n    var tok = this.idx !== -1 ? this.siblings[this.idx] : null;\r\n    if (tok !== this) {\r\n      this.idx = this.siblings.indexOf(this);\r\n    }\r\n    return this.idx;\r\n  }\r\n});\r\n\r\n/**\r\n * Get the previous node from the siblings array or `null`.\r\n *\r\n * ```js\r\n * var foo = new Node({type: 'foo'});\r\n * var bar = new Node({type: 'bar'});\r\n * var baz = new Node({type: 'baz'});\r\n * foo.push(bar);\r\n * foo.push(baz);\r\n *\r\n * console.log(baz.prev.type) // 'bar'\r\n * ```\r\n * @return {Object}\r\n * @api public\r\n */\r\n\r\nObject.defineProperty(Node.prototype, 'prev', {\r\n  set: function() {\r\n    throw new Error('node.prev is a getter and cannot be defined');\r\n  },\r\n  get: function() {\r\n    if (Array.isArray(this.siblings)) {\r\n      return this.siblings[this.index - 1] || this.parent.prev;\r\n    }\r\n    return null;\r\n  }\r\n});\r\n\r\n/**\r\n * Get the siblings array, or `null` if it doesn't exist.\r\n *\r\n * ```js\r\n * var foo = new Node({type: 'foo'});\r\n * var bar = new Node({type: 'bar'});\r\n * var baz = new Node({type: 'baz'});\r\n * foo.push(bar);\r\n * foo.push(baz);\r\n *\r\n * console.log(bar.siblings.length) // 2\r\n * console.log(baz.siblings.length) // 2\r\n * ```\r\n * @return {Object}\r\n * @api public\r\n */\r\n\r\nObject.defineProperty(Node.prototype, 'next', {\r\n  set: function() {\r\n    throw new Error('node.next is a getter and cannot be defined');\r\n  },\r\n  get: function() {\r\n    if (Array.isArray(this.siblings)) {\r\n      return this.siblings[this.index + 1] || this.parent.next;\r\n    }\r\n    return null;\r\n  }\r\n});\r\n\r\n/**\r\n * Get the first node from `node.nodes`.\r\n *\r\n * ```js\r\n * var foo = new Node({type: 'foo'});\r\n * var bar = new Node({type: 'bar'});\r\n * var baz = new Node({type: 'baz'});\r\n * var qux = new Node({type: 'qux'});\r\n * foo.push(bar);\r\n * foo.push(baz);\r\n * foo.push(qux);\r\n *\r\n * console.log(foo.first.type) // 'bar'\r\n * ```\r\n * @return {Object} The first node, or undefiend\r\n * @api public\r\n */\r\n\r\nObject.defineProperty(Node.prototype, 'first', {\r\n  get: function() {\r\n    return this.nodes ? this.nodes[0] : null;\r\n  }\r\n});\r\n\r\n/**\r\n * Get the last node from `node.nodes`.\r\n *\r\n * ```js\r\n * var foo = new Node({type: 'foo'});\r\n * var bar = new Node({type: 'bar'});\r\n * var baz = new Node({type: 'baz'});\r\n * var qux = new Node({type: 'qux'});\r\n * foo.push(bar);\r\n * foo.push(baz);\r\n * foo.push(qux);\r\n *\r\n * console.log(foo.last.type) // 'qux'\r\n * ```\r\n * @return {Object} The last node, or undefiend\r\n * @api public\r\n */\r\n\r\nObject.defineProperty(Node.prototype, 'last', {\r\n  get: function() {\r\n    return this.nodes ? utils.last(this.nodes) : null;\r\n  }\r\n});\r\n\r\n/**\r\n * Get the last node from `node.nodes`.\r\n *\r\n * ```js\r\n * var foo = new Node({type: 'foo'});\r\n * var bar = new Node({type: 'bar'});\r\n * var baz = new Node({type: 'baz'});\r\n * var qux = new Node({type: 'qux'});\r\n * foo.push(bar);\r\n * foo.push(baz);\r\n * foo.push(qux);\r\n *\r\n * console.log(foo.last.type) // 'qux'\r\n * ```\r\n * @return {Object} The last node, or undefiend\r\n * @api public\r\n */\r\n\r\nObject.defineProperty(Node.prototype, 'scope', {\r\n  get: function() {\r\n    if (this.isScope !== true) {\r\n      return this.parent ? this.parent.scope : this;\r\n    }\r\n    return this;\r\n  }\r\n});\r\n\r\n/**\r\n * Get own property names from Node prototype, but only the\r\n * first time `Node` is instantiated\r\n */\r\n\r\nfunction lazyKeys() {\r\n  if (!ownNames) {\r\n    ownNames = Object.getOwnPropertyNames(Node.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Simplified assertion. Throws an error is `val` is falsey.\r\n */\r\n\r\nfunction assert(val, message) {\r\n  if (!val) throw new Error(message);\r\n}\r\n\r\n/**\r\n * Expose `Node`\r\n */\r\n\r\nexports = module.exports = Node;\r\n"]},"metadata":{},"sourceType":"script"}