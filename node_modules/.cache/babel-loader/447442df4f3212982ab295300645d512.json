{"ast":null,"code":"'use strict';\n\nvar use = require('use');\n\nvar util = require('util');\n\nvar Cache = require('map-cache');\n\nvar define = require('define-property');\n\nvar debug = require('debug')('snapdragon:parser');\n\nvar Position = require('./position');\n\nvar utils = require('./utils');\n/**\r\n * Create a new `Parser` with the given `input` and `options`.\r\n * @param {String} `input`\r\n * @param {Object} `options`\r\n * @api public\r\n */\n\n\nfunction Parser(options) {\n  debug('initializing', __filename);\n  this.options = utils.extend({\n    source: 'string'\n  }, options);\n  this.init(this.options);\n  use(this);\n}\n/**\r\n * Prototype methods\r\n */\n\n\nParser.prototype = {\n  constructor: Parser,\n  init: function (options) {\n    this.orig = '';\n    this.input = '';\n    this.parsed = '';\n    this.column = 1;\n    this.line = 1;\n    this.regex = new Cache();\n    this.errors = this.errors || [];\n    this.parsers = this.parsers || {};\n    this.types = this.types || [];\n    this.sets = this.sets || {};\n    this.fns = this.fns || [];\n    this.currentType = 'root';\n    var pos = this.position();\n    this.bos = pos({\n      type: 'bos',\n      val: ''\n    });\n    this.ast = {\n      type: 'root',\n      errors: this.errors,\n      nodes: [this.bos]\n    };\n    define(this.bos, 'parent', this.ast);\n    this.nodes = [this.ast];\n    this.count = 0;\n    this.setCount = 0;\n    this.stack = [];\n  },\n\n  /**\r\n   * Throw a formatted error with the cursor column and `msg`.\r\n   * @param {String} `msg` Message to use in the Error.\r\n   */\n  error: function (msg, node) {\n    var pos = node.position || {\n      start: {\n        column: 0,\n        line: 0\n      }\n    };\n    var line = pos.start.line;\n    var column = pos.start.column;\n    var source = this.options.source;\n    var message = source + ' <line:' + line + ' column:' + column + '>: ' + msg;\n    var err = new Error(message);\n    err.source = source;\n    err.reason = msg;\n    err.pos = pos;\n\n    if (this.options.silent) {\n      this.errors.push(err);\n    } else {\n      throw err;\n    }\n  },\n\n  /**\r\n   * Define a non-enumberable property on the `Parser` instance.\r\n   *\r\n   * ```js\r\n   * parser.define('foo', 'bar');\r\n   * ```\r\n   * @name .define\r\n   * @param {String} `key` propery name\r\n   * @param {any} `val` property value\r\n   * @return {Object} Returns the Parser instance for chaining.\r\n   * @api public\r\n   */\n  define: function (key, val) {\n    define(this, key, val);\n    return this;\n  },\n\n  /**\r\n   * Mark position and patch `node.position`.\r\n   */\n  position: function () {\n    var start = {\n      line: this.line,\n      column: this.column\n    };\n    var self = this;\n    return function (node) {\n      define(node, 'position', new Position(start, self));\n      return node;\n    };\n  },\n\n  /**\r\n   * Set parser `name` with the given `fn`\r\n   * @param {String} `name`\r\n   * @param {Function} `fn`\r\n   * @api public\r\n   */\n  set: function (type, fn) {\n    if (this.types.indexOf(type) === -1) {\n      this.types.push(type);\n    }\n\n    this.parsers[type] = fn.bind(this);\n    return this;\n  },\n\n  /**\r\n   * Get parser `name`\r\n   * @param {String} `name`\r\n   * @api public\r\n   */\n  get: function (name) {\n    return this.parsers[name];\n  },\n\n  /**\r\n   * Push a `token` onto the `type` stack.\r\n   *\r\n   * @param {String} `type`\r\n   * @return {Object} `token`\r\n   * @api public\r\n   */\n  push: function (type, token) {\n    this.sets[type] = this.sets[type] || [];\n    this.count++;\n    this.stack.push(token);\n    return this.sets[type].push(token);\n  },\n\n  /**\r\n   * Pop a token off of the `type` stack\r\n   * @param {String} `type`\r\n   * @returns {Object} Returns a token\r\n   * @api public\r\n   */\n  pop: function (type) {\n    this.sets[type] = this.sets[type] || [];\n    this.count--;\n    this.stack.pop();\n    return this.sets[type].pop();\n  },\n\n  /**\r\n   * Return true if inside a `stack` node. Types are `braces`, `parens` or `brackets`.\r\n   *\r\n   * @param {String} `type`\r\n   * @return {Boolean}\r\n   * @api public\r\n   */\n  isInside: function (type) {\n    this.sets[type] = this.sets[type] || [];\n    return this.sets[type].length > 0;\n  },\n\n  /**\r\n   * Return true if `node` is the given `type`.\r\n   *\r\n   * ```js\r\n   * parser.isType(node, 'brace');\r\n   * ```\r\n   * @param {Object} `node`\r\n   * @param {String} `type`\r\n   * @return {Boolean}\r\n   * @api public\r\n   */\n  isType: function (node, type) {\n    return node && node.type === type;\n  },\n\n  /**\r\n   * Get the previous AST node\r\n   * @return {Object}\r\n   */\n  prev: function (n) {\n    return this.stack.length > 0 ? utils.last(this.stack, n) : utils.last(this.nodes, n);\n  },\n\n  /**\r\n   * Update line and column based on `str`.\r\n   */\n  consume: function (len) {\n    this.input = this.input.substr(len);\n  },\n\n  /**\r\n   * Update column based on `str`.\r\n   */\n  updatePosition: function (str, len) {\n    var lines = str.match(/\\n/g);\n    if (lines) this.line += lines.length;\n    var i = str.lastIndexOf('\\n');\n    this.column = ~i ? len - i : this.column + len;\n    this.parsed += str;\n    this.consume(len);\n  },\n\n  /**\r\n   * Match `regex`, return captures, and update the cursor position by `match[0]` length.\r\n   * @param {RegExp} `regex`\r\n   * @return {Object}\r\n   */\n  match: function (regex) {\n    var m = regex.exec(this.input);\n\n    if (m) {\n      this.updatePosition(m[0], m[0].length);\n      return m;\n    }\n  },\n\n  /**\r\n   * Capture `type` with the given regex.\r\n   * @param {String} `type`\r\n   * @param {RegExp} `regex`\r\n   * @return {Function}\r\n   */\n  capture: function (type, regex) {\n    if (typeof regex === 'function') {\n      return this.set.apply(this, arguments);\n    }\n\n    this.regex.set(type, regex);\n    this.set(type, function () {\n      var parsed = this.parsed;\n      var pos = this.position();\n      var m = this.match(regex);\n      if (!m || !m[0]) return;\n      var prev = this.prev();\n      var node = pos({\n        type: type,\n        val: m[0],\n        parsed: parsed,\n        rest: this.input\n      });\n\n      if (m[1]) {\n        node.inner = m[1];\n      }\n\n      define(node, 'inside', this.stack.length > 0);\n      define(node, 'parent', prev);\n      prev.nodes.push(node);\n    }.bind(this));\n    return this;\n  },\n\n  /**\r\n   * Create a parser with open and close for parens,\r\n   * brackets or braces\r\n   */\n  capturePair: function (type, openRegex, closeRegex, fn) {\n    this.sets[type] = this.sets[type] || [];\n    /**\r\n     * Open\r\n     */\n\n    this.set(type + '.open', function () {\n      var parsed = this.parsed;\n      var pos = this.position();\n      var m = this.match(openRegex);\n      if (!m || !m[0]) return;\n      var val = m[0];\n      this.setCount++;\n      this.specialChars = true;\n      var open = pos({\n        type: type + '.open',\n        val: val,\n        rest: this.input\n      });\n\n      if (typeof m[1] !== 'undefined') {\n        open.inner = m[1];\n      }\n\n      var prev = this.prev();\n      var node = pos({\n        type: type,\n        nodes: [open]\n      });\n      define(node, 'rest', this.input);\n      define(node, 'parsed', parsed);\n      define(node, 'prefix', m[1]);\n      define(node, 'parent', prev);\n      define(open, 'parent', node);\n\n      if (typeof fn === 'function') {\n        fn.call(this, open, node);\n      }\n\n      this.push(type, node);\n      prev.nodes.push(node);\n    });\n    /**\r\n     * Close\r\n     */\n\n    this.set(type + '.close', function () {\n      var pos = this.position();\n      var m = this.match(closeRegex);\n      if (!m || !m[0]) return;\n      var parent = this.pop(type);\n      var node = pos({\n        type: type + '.close',\n        rest: this.input,\n        suffix: m[1],\n        val: m[0]\n      });\n\n      if (!this.isType(parent, type)) {\n        if (this.options.strict) {\n          throw new Error('missing opening \"' + type + '\"');\n        }\n\n        this.setCount--;\n        node.escaped = true;\n        return node;\n      }\n\n      if (node.suffix === '\\\\') {\n        parent.escaped = true;\n        node.escaped = true;\n      }\n\n      parent.nodes.push(node);\n      define(node, 'parent', parent);\n    });\n    return this;\n  },\n\n  /**\r\n   * Capture end-of-string\r\n   */\n  eos: function () {\n    var pos = this.position();\n    if (this.input) return;\n    var prev = this.prev();\n\n    while (prev.type !== 'root' && !prev.visited) {\n      if (this.options.strict === true) {\n        throw new SyntaxError('invalid syntax:' + util.inspect(prev, null, 2));\n      }\n\n      if (!hasDelims(prev)) {\n        prev.parent.escaped = true;\n        prev.escaped = true;\n      }\n\n      visit(prev, function (node) {\n        if (!hasDelims(node.parent)) {\n          node.parent.escaped = true;\n          node.escaped = true;\n        }\n      });\n      prev = prev.parent;\n    }\n\n    var tok = pos({\n      type: 'eos',\n      val: this.append || ''\n    });\n    define(tok, 'parent', this.ast);\n    return tok;\n  },\n\n  /**\r\n   * Run parsers to advance the cursor position\r\n   */\n  next: function () {\n    var parsed = this.parsed;\n    var len = this.types.length;\n    var idx = -1;\n    var tok;\n\n    while (++idx < len) {\n      if (tok = this.parsers[this.types[idx]].call(this)) {\n        define(tok, 'rest', this.input);\n        define(tok, 'parsed', parsed);\n        this.last = tok;\n        return tok;\n      }\n    }\n  },\n\n  /**\r\n   * Parse the given string.\r\n   * @return {Array}\r\n   */\n  parse: function (input) {\n    if (typeof input !== 'string') {\n      throw new TypeError('expected a string');\n    }\n\n    this.init(this.options);\n    this.orig = input;\n    this.input = input;\n    var self = this;\n\n    function parse() {\n      // check input before calling `.next()`\n      input = self.input; // get the next AST ndoe\n\n      var node = self.next();\n\n      if (node) {\n        var prev = self.prev();\n\n        if (prev) {\n          define(node, 'parent', prev);\n\n          if (prev.nodes) {\n            prev.nodes.push(node);\n          }\n        }\n\n        if (self.sets.hasOwnProperty(prev.type)) {\n          self.currentType = prev.type;\n        }\n      } // if we got here but input is not changed, throw an error\n\n\n      if (self.input && input === self.input) {\n        throw new Error('no parsers registered for: \"' + self.input.slice(0, 5) + '\"');\n      }\n    }\n\n    while (this.input) parse();\n\n    if (this.stack.length && this.options.strict) {\n      var node = this.stack.pop();\n      throw this.error('missing opening ' + node.type + ': \"' + this.orig + '\"');\n    }\n\n    var eos = this.eos();\n    var tok = this.prev();\n\n    if (tok.type !== 'eos') {\n      this.ast.nodes.push(eos);\n    }\n\n    return this.ast;\n  }\n};\n/**\r\n * Visit `node` with the given `fn`\r\n */\n\nfunction visit(node, fn) {\n  if (!node.visited) {\n    define(node, 'visited', true);\n    return node.nodes ? mapVisit(node.nodes, fn) : fn(node);\n  }\n\n  return node;\n}\n/**\r\n * Map visit over array of `nodes`.\r\n */\n\n\nfunction mapVisit(nodes, fn) {\n  var len = nodes.length;\n  var idx = -1;\n\n  while (++idx < len) {\n    visit(nodes[idx], fn);\n  }\n}\n\nfunction hasOpen(node) {\n  return node.nodes && node.nodes[0].type === node.type + '.open';\n}\n\nfunction hasClose(node) {\n  return node.nodes && utils.last(node.nodes).type === node.type + '.close';\n}\n\nfunction hasDelims(node) {\n  return hasOpen(node) && hasClose(node);\n}\n/**\r\n * Expose `Parser`\r\n */\n\n\nmodule.exports = Parser;","map":{"version":3,"sources":["C:/frontend/node_modules/snapdragon/lib/parser.js"],"names":["use","require","util","Cache","define","debug","Position","utils","Parser","options","__filename","extend","source","init","prototype","constructor","orig","input","parsed","column","line","regex","errors","parsers","types","sets","fns","currentType","pos","position","bos","type","val","ast","nodes","count","setCount","stack","error","msg","node","start","message","err","Error","reason","silent","push","key","self","set","fn","indexOf","bind","get","name","token","pop","isInside","length","isType","prev","n","last","consume","len","substr","updatePosition","str","lines","match","i","lastIndexOf","m","exec","capture","apply","arguments","rest","inner","capturePair","openRegex","closeRegex","specialChars","open","call","parent","suffix","strict","escaped","eos","visited","SyntaxError","inspect","hasDelims","visit","tok","append","next","idx","parse","TypeError","hasOwnProperty","slice","mapVisit","hasOpen","hasClose","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nvar use = require('use');\r\nvar util = require('util');\r\nvar Cache = require('map-cache');\r\nvar define = require('define-property');\r\nvar debug = require('debug')('snapdragon:parser');\r\nvar Position = require('./position');\r\nvar utils = require('./utils');\r\n\r\n/**\r\n * Create a new `Parser` with the given `input` and `options`.\r\n * @param {String} `input`\r\n * @param {Object} `options`\r\n * @api public\r\n */\r\n\r\nfunction Parser(options) {\r\n  debug('initializing', __filename);\r\n  this.options = utils.extend({source: 'string'}, options);\r\n  this.init(this.options);\r\n  use(this);\r\n}\r\n\r\n/**\r\n * Prototype methods\r\n */\r\n\r\nParser.prototype = {\r\n  constructor: Parser,\r\n\r\n  init: function(options) {\r\n    this.orig = '';\r\n    this.input = '';\r\n    this.parsed = '';\r\n\r\n    this.column = 1;\r\n    this.line = 1;\r\n\r\n    this.regex = new Cache();\r\n    this.errors = this.errors || [];\r\n    this.parsers = this.parsers || {};\r\n    this.types = this.types || [];\r\n    this.sets = this.sets || {};\r\n    this.fns = this.fns || [];\r\n    this.currentType = 'root';\r\n\r\n    var pos = this.position();\r\n    this.bos = pos({type: 'bos', val: ''});\r\n\r\n    this.ast = {\r\n      type: 'root',\r\n      errors: this.errors,\r\n      nodes: [this.bos]\r\n    };\r\n\r\n    define(this.bos, 'parent', this.ast);\r\n    this.nodes = [this.ast];\r\n\r\n    this.count = 0;\r\n    this.setCount = 0;\r\n    this.stack = [];\r\n  },\r\n\r\n  /**\r\n   * Throw a formatted error with the cursor column and `msg`.\r\n   * @param {String} `msg` Message to use in the Error.\r\n   */\r\n\r\n  error: function(msg, node) {\r\n    var pos = node.position || {start: {column: 0, line: 0}};\r\n    var line = pos.start.line;\r\n    var column = pos.start.column;\r\n    var source = this.options.source;\r\n\r\n    var message = source + ' <line:' + line + ' column:' + column + '>: ' + msg;\r\n    var err = new Error(message);\r\n    err.source = source;\r\n    err.reason = msg;\r\n    err.pos = pos;\r\n\r\n    if (this.options.silent) {\r\n      this.errors.push(err);\r\n    } else {\r\n      throw err;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Define a non-enumberable property on the `Parser` instance.\r\n   *\r\n   * ```js\r\n   * parser.define('foo', 'bar');\r\n   * ```\r\n   * @name .define\r\n   * @param {String} `key` propery name\r\n   * @param {any} `val` property value\r\n   * @return {Object} Returns the Parser instance for chaining.\r\n   * @api public\r\n   */\r\n\r\n  define: function(key, val) {\r\n    define(this, key, val);\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Mark position and patch `node.position`.\r\n   */\r\n\r\n  position: function() {\r\n    var start = { line: this.line, column: this.column };\r\n    var self = this;\r\n\r\n    return function(node) {\r\n      define(node, 'position', new Position(start, self));\r\n      return node;\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Set parser `name` with the given `fn`\r\n   * @param {String} `name`\r\n   * @param {Function} `fn`\r\n   * @api public\r\n   */\r\n\r\n  set: function(type, fn) {\r\n    if (this.types.indexOf(type) === -1) {\r\n      this.types.push(type);\r\n    }\r\n    this.parsers[type] = fn.bind(this);\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Get parser `name`\r\n   * @param {String} `name`\r\n   * @api public\r\n   */\r\n\r\n  get: function(name) {\r\n    return this.parsers[name];\r\n  },\r\n\r\n  /**\r\n   * Push a `token` onto the `type` stack.\r\n   *\r\n   * @param {String} `type`\r\n   * @return {Object} `token`\r\n   * @api public\r\n   */\r\n\r\n  push: function(type, token) {\r\n    this.sets[type] = this.sets[type] || [];\r\n    this.count++;\r\n    this.stack.push(token);\r\n    return this.sets[type].push(token);\r\n  },\r\n\r\n  /**\r\n   * Pop a token off of the `type` stack\r\n   * @param {String} `type`\r\n   * @returns {Object} Returns a token\r\n   * @api public\r\n   */\r\n\r\n  pop: function(type) {\r\n    this.sets[type] = this.sets[type] || [];\r\n    this.count--;\r\n    this.stack.pop();\r\n    return this.sets[type].pop();\r\n  },\r\n\r\n  /**\r\n   * Return true if inside a `stack` node. Types are `braces`, `parens` or `brackets`.\r\n   *\r\n   * @param {String} `type`\r\n   * @return {Boolean}\r\n   * @api public\r\n   */\r\n\r\n  isInside: function(type) {\r\n    this.sets[type] = this.sets[type] || [];\r\n    return this.sets[type].length > 0;\r\n  },\r\n\r\n  /**\r\n   * Return true if `node` is the given `type`.\r\n   *\r\n   * ```js\r\n   * parser.isType(node, 'brace');\r\n   * ```\r\n   * @param {Object} `node`\r\n   * @param {String} `type`\r\n   * @return {Boolean}\r\n   * @api public\r\n   */\r\n\r\n  isType: function(node, type) {\r\n    return node && node.type === type;\r\n  },\r\n\r\n  /**\r\n   * Get the previous AST node\r\n   * @return {Object}\r\n   */\r\n\r\n  prev: function(n) {\r\n    return this.stack.length > 0\r\n      ? utils.last(this.stack, n)\r\n      : utils.last(this.nodes, n);\r\n  },\r\n\r\n  /**\r\n   * Update line and column based on `str`.\r\n   */\r\n\r\n  consume: function(len) {\r\n    this.input = this.input.substr(len);\r\n  },\r\n\r\n  /**\r\n   * Update column based on `str`.\r\n   */\r\n\r\n  updatePosition: function(str, len) {\r\n    var lines = str.match(/\\n/g);\r\n    if (lines) this.line += lines.length;\r\n    var i = str.lastIndexOf('\\n');\r\n    this.column = ~i ? len - i : this.column + len;\r\n    this.parsed += str;\r\n    this.consume(len);\r\n  },\r\n\r\n  /**\r\n   * Match `regex`, return captures, and update the cursor position by `match[0]` length.\r\n   * @param {RegExp} `regex`\r\n   * @return {Object}\r\n   */\r\n\r\n  match: function(regex) {\r\n    var m = regex.exec(this.input);\r\n    if (m) {\r\n      this.updatePosition(m[0], m[0].length);\r\n      return m;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Capture `type` with the given regex.\r\n   * @param {String} `type`\r\n   * @param {RegExp} `regex`\r\n   * @return {Function}\r\n   */\r\n\r\n  capture: function(type, regex) {\r\n    if (typeof regex === 'function') {\r\n      return this.set.apply(this, arguments);\r\n    }\r\n\r\n    this.regex.set(type, regex);\r\n    this.set(type, function() {\r\n      var parsed = this.parsed;\r\n      var pos = this.position();\r\n      var m = this.match(regex);\r\n      if (!m || !m[0]) return;\r\n\r\n      var prev = this.prev();\r\n      var node = pos({\r\n        type: type,\r\n        val: m[0],\r\n        parsed: parsed,\r\n        rest: this.input\r\n      });\r\n\r\n      if (m[1]) {\r\n        node.inner = m[1];\r\n      }\r\n\r\n      define(node, 'inside', this.stack.length > 0);\r\n      define(node, 'parent', prev);\r\n      prev.nodes.push(node);\r\n    }.bind(this));\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Create a parser with open and close for parens,\r\n   * brackets or braces\r\n   */\r\n\r\n  capturePair: function(type, openRegex, closeRegex, fn) {\r\n    this.sets[type] = this.sets[type] || [];\r\n\r\n    /**\r\n     * Open\r\n     */\r\n\r\n    this.set(type + '.open', function() {\r\n      var parsed = this.parsed;\r\n      var pos = this.position();\r\n      var m = this.match(openRegex);\r\n      if (!m || !m[0]) return;\r\n\r\n      var val = m[0];\r\n      this.setCount++;\r\n      this.specialChars = true;\r\n      var open = pos({\r\n        type: type + '.open',\r\n        val: val,\r\n        rest: this.input\r\n      });\r\n\r\n      if (typeof m[1] !== 'undefined') {\r\n        open.inner = m[1];\r\n      }\r\n\r\n      var prev = this.prev();\r\n      var node = pos({\r\n        type: type,\r\n        nodes: [open]\r\n      });\r\n\r\n      define(node, 'rest', this.input);\r\n      define(node, 'parsed', parsed);\r\n      define(node, 'prefix', m[1]);\r\n      define(node, 'parent', prev);\r\n      define(open, 'parent', node);\r\n\r\n      if (typeof fn === 'function') {\r\n        fn.call(this, open, node);\r\n      }\r\n\r\n      this.push(type, node);\r\n      prev.nodes.push(node);\r\n    });\r\n\r\n    /**\r\n     * Close\r\n     */\r\n\r\n    this.set(type + '.close', function() {\r\n      var pos = this.position();\r\n      var m = this.match(closeRegex);\r\n      if (!m || !m[0]) return;\r\n\r\n      var parent = this.pop(type);\r\n      var node = pos({\r\n        type: type + '.close',\r\n        rest: this.input,\r\n        suffix: m[1],\r\n        val: m[0]\r\n      });\r\n\r\n      if (!this.isType(parent, type)) {\r\n        if (this.options.strict) {\r\n          throw new Error('missing opening \"' + type + '\"');\r\n        }\r\n\r\n        this.setCount--;\r\n        node.escaped = true;\r\n        return node;\r\n      }\r\n\r\n      if (node.suffix === '\\\\') {\r\n        parent.escaped = true;\r\n        node.escaped = true;\r\n      }\r\n\r\n      parent.nodes.push(node);\r\n      define(node, 'parent', parent);\r\n    });\r\n\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Capture end-of-string\r\n   */\r\n\r\n  eos: function() {\r\n    var pos = this.position();\r\n    if (this.input) return;\r\n    var prev = this.prev();\r\n\r\n    while (prev.type !== 'root' && !prev.visited) {\r\n      if (this.options.strict === true) {\r\n        throw new SyntaxError('invalid syntax:' + util.inspect(prev, null, 2));\r\n      }\r\n\r\n      if (!hasDelims(prev)) {\r\n        prev.parent.escaped = true;\r\n        prev.escaped = true;\r\n      }\r\n\r\n      visit(prev, function(node) {\r\n        if (!hasDelims(node.parent)) {\r\n          node.parent.escaped = true;\r\n          node.escaped = true;\r\n        }\r\n      });\r\n\r\n      prev = prev.parent;\r\n    }\r\n\r\n    var tok = pos({\r\n      type: 'eos',\r\n      val: this.append || ''\r\n    });\r\n\r\n    define(tok, 'parent', this.ast);\r\n    return tok;\r\n  },\r\n\r\n  /**\r\n   * Run parsers to advance the cursor position\r\n   */\r\n\r\n  next: function() {\r\n    var parsed = this.parsed;\r\n    var len = this.types.length;\r\n    var idx = -1;\r\n    var tok;\r\n\r\n    while (++idx < len) {\r\n      if ((tok = this.parsers[this.types[idx]].call(this))) {\r\n        define(tok, 'rest', this.input);\r\n        define(tok, 'parsed', parsed);\r\n        this.last = tok;\r\n        return tok;\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Parse the given string.\r\n   * @return {Array}\r\n   */\r\n\r\n  parse: function(input) {\r\n    if (typeof input !== 'string') {\r\n      throw new TypeError('expected a string');\r\n    }\r\n\r\n    this.init(this.options);\r\n    this.orig = input;\r\n    this.input = input;\r\n    var self = this;\r\n\r\n    function parse() {\r\n      // check input before calling `.next()`\r\n      input = self.input;\r\n\r\n      // get the next AST ndoe\r\n      var node = self.next();\r\n      if (node) {\r\n        var prev = self.prev();\r\n        if (prev) {\r\n          define(node, 'parent', prev);\r\n          if (prev.nodes) {\r\n            prev.nodes.push(node);\r\n          }\r\n        }\r\n\r\n        if (self.sets.hasOwnProperty(prev.type)) {\r\n          self.currentType = prev.type;\r\n        }\r\n      }\r\n\r\n      // if we got here but input is not changed, throw an error\r\n      if (self.input && input === self.input) {\r\n        throw new Error('no parsers registered for: \"' + self.input.slice(0, 5) + '\"');\r\n      }\r\n    }\r\n\r\n    while (this.input) parse();\r\n    if (this.stack.length && this.options.strict) {\r\n      var node = this.stack.pop();\r\n      throw this.error('missing opening ' + node.type + ': \"' + this.orig + '\"');\r\n    }\r\n\r\n    var eos = this.eos();\r\n    var tok = this.prev();\r\n    if (tok.type !== 'eos') {\r\n      this.ast.nodes.push(eos);\r\n    }\r\n\r\n    return this.ast;\r\n  }\r\n};\r\n\r\n/**\r\n * Visit `node` with the given `fn`\r\n */\r\n\r\nfunction visit(node, fn) {\r\n  if (!node.visited) {\r\n    define(node, 'visited', true);\r\n    return node.nodes ? mapVisit(node.nodes, fn) : fn(node);\r\n  }\r\n  return node;\r\n}\r\n\r\n/**\r\n * Map visit over array of `nodes`.\r\n */\r\n\r\nfunction mapVisit(nodes, fn) {\r\n  var len = nodes.length;\r\n  var idx = -1;\r\n  while (++idx < len) {\r\n    visit(nodes[idx], fn);\r\n  }\r\n}\r\n\r\nfunction hasOpen(node) {\r\n  return node.nodes && node.nodes[0].type === (node.type + '.open');\r\n}\r\n\r\nfunction hasClose(node) {\r\n  return node.nodes && utils.last(node.nodes).type === (node.type + '.close');\r\n}\r\n\r\nfunction hasDelims(node) {\r\n  return hasOpen(node) && hasClose(node);\r\n}\r\n\r\n/**\r\n * Expose `Parser`\r\n */\r\n\r\nmodule.exports = Parser;\r\n"]},"metadata":{},"sourceType":"script"}