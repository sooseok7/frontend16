{"ast":null,"code":"/*!\r\n * use <https://github.com/jonschlinkert/use>\r\n *\r\n * Copyright (c) 2015-2017, Jon Schlinkert.\r\n * Released under the MIT License.\r\n */\n'use strict';\n\nmodule.exports = function base(app, options) {\n  if (!isObject(app) && typeof app !== 'function') {\n    throw new TypeError('expected an object or function');\n  }\n\n  var opts = isObject(options) ? options : {};\n  var prop = typeof opts.prop === 'string' ? opts.prop : 'fns';\n\n  if (!Array.isArray(app[prop])) {\n    define(app, prop, []);\n  }\n  /**\r\n   * Define a plugin function to be passed to use. The only\r\n   * parameter exposed to the plugin is `app`, the object or function.\r\n   * passed to `use(app)`. `app` is also exposed as `this` in plugins.\r\n   *\r\n   * Additionally, **if a plugin returns a function, the function will\r\n   * be pushed onto the `fns` array**, allowing the plugin to be\r\n   * called at a later point by the `run` method.\r\n   *\r\n   * ```js\r\n   * var use = require('use');\r\n   *\r\n   * // define a plugin\r\n   * function foo(app) {\r\n   *   // do stuff\r\n   * }\r\n   *\r\n   * var app = function(){};\r\n   * use(app);\r\n   *\r\n   * // register plugins\r\n   * app.use(foo);\r\n   * app.use(bar);\r\n   * app.use(baz);\r\n   * ```\r\n   * @name .use\r\n   * @param {Function} `fn` plugin function to call\r\n   * @api public\r\n   */\n\n\n  define(app, 'use', use);\n  /**\r\n   * Run all plugins on `fns`. Any plugin that returns a function\r\n   * when called by `use` is pushed onto the `fns` array.\r\n   *\r\n   * ```js\r\n   * var config = {};\r\n   * app.run(config);\r\n   * ```\r\n   * @name .run\r\n   * @param {Object} `value` Object to be modified by plugins.\r\n   * @return {Object} Returns the object passed to `run`\r\n   * @api public\r\n   */\n\n  define(app, 'run', function (val) {\n    if (!isObject(val)) return;\n\n    if (!val.use || !val.run) {\n      define(val, prop, val[prop] || []);\n      define(val, 'use', use);\n    }\n\n    if (!val[prop] || val[prop].indexOf(base) === -1) {\n      val.use(base);\n    }\n\n    var self = this || app;\n    var fns = self[prop];\n    var len = fns.length;\n    var idx = -1;\n\n    while (++idx < len) {\n      val.use(fns[idx]);\n    }\n\n    return val;\n  });\n  /**\r\n   * Call plugin `fn`. If a function is returned push it into the\r\n   * `fns` array to be called by the `run` method.\r\n   */\n\n  function use(type, fn, options) {\n    var offset = 1;\n\n    if (typeof type === 'string' || Array.isArray(type)) {\n      fn = wrap(type, fn);\n      offset++;\n    } else {\n      options = fn;\n      fn = type;\n    }\n\n    if (typeof fn !== 'function') {\n      throw new TypeError('expected a function');\n    }\n\n    var self = this || app;\n    var fns = self[prop];\n    var args = [].slice.call(arguments, offset);\n    args.unshift(self);\n\n    if (typeof opts.hook === 'function') {\n      opts.hook.apply(self, args);\n    }\n\n    var val = fn.apply(self, args);\n\n    if (typeof val === 'function' && fns.indexOf(val) === -1) {\n      fns.push(val);\n    }\n\n    return self;\n  }\n  /**\r\n   * Wrap a named plugin function so that it's only called on objects of the\r\n   * given `type`\r\n   *\r\n   * @param {String} `type`\r\n   * @param {Function} `fn` Plugin function\r\n   * @return {Function}\r\n   */\n\n\n  function wrap(type, fn) {\n    return function plugin() {\n      return this.type === type ? fn.apply(this, arguments) : plugin;\n    };\n  }\n\n  return app;\n};\n\nfunction isObject(val) {\n  return val && typeof val === 'object' && !Array.isArray(val);\n}\n\nfunction define(obj, key, val) {\n  Object.defineProperty(obj, key, {\n    configurable: true,\n    writable: true,\n    value: val\n  });\n}","map":{"version":3,"sources":["C:/frontend/node_modules/use/index.js"],"names":["module","exports","base","app","options","isObject","TypeError","opts","prop","Array","isArray","define","use","val","run","indexOf","self","fns","len","length","idx","type","fn","offset","wrap","args","slice","call","arguments","unshift","hook","apply","push","plugin","obj","key","Object","defineProperty","configurable","writable","value"],"mappings":"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","sourcesContent":["/*!\r\n * use <https://github.com/jonschlinkert/use>\r\n *\r\n * Copyright (c) 2015-2017, Jon Schlinkert.\r\n * Released under the MIT License.\r\n */\r\n\r\n'use strict';\r\n\r\nmodule.exports = function base(app, options) {\r\n  if (!isObject(app) && typeof app !== 'function') {\r\n    throw new TypeError('expected an object or function');\r\n  }\r\n\r\n  var opts = isObject(options) ? options : {};\r\n  var prop = typeof opts.prop === 'string' ? opts.prop : 'fns';\r\n  if (!Array.isArray(app[prop])) {\r\n    define(app, prop, []);\r\n  }\r\n\r\n  /**\r\n   * Define a plugin function to be passed to use. The only\r\n   * parameter exposed to the plugin is `app`, the object or function.\r\n   * passed to `use(app)`. `app` is also exposed as `this` in plugins.\r\n   *\r\n   * Additionally, **if a plugin returns a function, the function will\r\n   * be pushed onto the `fns` array**, allowing the plugin to be\r\n   * called at a later point by the `run` method.\r\n   *\r\n   * ```js\r\n   * var use = require('use');\r\n   *\r\n   * // define a plugin\r\n   * function foo(app) {\r\n   *   // do stuff\r\n   * }\r\n   *\r\n   * var app = function(){};\r\n   * use(app);\r\n   *\r\n   * // register plugins\r\n   * app.use(foo);\r\n   * app.use(bar);\r\n   * app.use(baz);\r\n   * ```\r\n   * @name .use\r\n   * @param {Function} `fn` plugin function to call\r\n   * @api public\r\n   */\r\n\r\n  define(app, 'use', use);\r\n\r\n  /**\r\n   * Run all plugins on `fns`. Any plugin that returns a function\r\n   * when called by `use` is pushed onto the `fns` array.\r\n   *\r\n   * ```js\r\n   * var config = {};\r\n   * app.run(config);\r\n   * ```\r\n   * @name .run\r\n   * @param {Object} `value` Object to be modified by plugins.\r\n   * @return {Object} Returns the object passed to `run`\r\n   * @api public\r\n   */\r\n\r\n  define(app, 'run', function(val) {\r\n    if (!isObject(val)) return;\r\n\r\n    if (!val.use || !val.run) {\r\n      define(val, prop, val[prop] || []);\r\n      define(val, 'use', use);\r\n    }\r\n\r\n    if (!val[prop] || val[prop].indexOf(base) === -1) {\r\n      val.use(base);\r\n    }\r\n\r\n    var self = this || app;\r\n    var fns = self[prop];\r\n    var len = fns.length;\r\n    var idx = -1;\r\n\r\n    while (++idx < len) {\r\n      val.use(fns[idx]);\r\n    }\r\n    return val;\r\n  });\r\n\r\n  /**\r\n   * Call plugin `fn`. If a function is returned push it into the\r\n   * `fns` array to be called by the `run` method.\r\n   */\r\n\r\n  function use(type, fn, options) {\r\n    var offset = 1;\r\n\r\n    if (typeof type === 'string' || Array.isArray(type)) {\r\n      fn = wrap(type, fn);\r\n      offset++;\r\n    } else {\r\n      options = fn;\r\n      fn = type;\r\n    }\r\n\r\n    if (typeof fn !== 'function') {\r\n      throw new TypeError('expected a function');\r\n    }\r\n\r\n    var self = this || app;\r\n    var fns = self[prop];\r\n\r\n    var args = [].slice.call(arguments, offset);\r\n    args.unshift(self);\r\n\r\n    if (typeof opts.hook === 'function') {\r\n      opts.hook.apply(self, args);\r\n    }\r\n\r\n    var val = fn.apply(self, args);\r\n    if (typeof val === 'function' && fns.indexOf(val) === -1) {\r\n      fns.push(val);\r\n    }\r\n    return self;\r\n  }\r\n\r\n  /**\r\n   * Wrap a named plugin function so that it's only called on objects of the\r\n   * given `type`\r\n   *\r\n   * @param {String} `type`\r\n   * @param {Function} `fn` Plugin function\r\n   * @return {Function}\r\n   */\r\n\r\n  function wrap(type, fn) {\r\n    return function plugin() {\r\n      return this.type === type ? fn.apply(this, arguments) : plugin;\r\n    };\r\n  }\r\n\r\n  return app;\r\n};\r\n\r\nfunction isObject(val) {\r\n  return val && typeof val === 'object' && !Array.isArray(val);\r\n}\r\n\r\nfunction define(obj, key, val) {\r\n  Object.defineProperty(obj, key, {\r\n    configurable: true,\r\n    writable: true,\r\n    value: val\r\n  });\r\n}\r\n"]},"metadata":{},"sourceType":"script"}