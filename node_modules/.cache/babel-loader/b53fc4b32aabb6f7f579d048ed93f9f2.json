{"ast":null,"code":"var types = require('./types');\n\nvar sets = require('./sets'); // All of these are private and only used by randexp.\n// It's assumed that they will always be called with the correct input.\n\n\nvar CTRL = '@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^ ?';\nvar SLSH = {\n  '0': 0,\n  't': 9,\n  'n': 10,\n  'v': 11,\n  'f': 12,\n  'r': 13\n};\n/**\r\n * Finds character representations in str and convert all to\r\n * their respective characters\r\n *\r\n * @param {String} str\r\n * @return {String}\r\n */\n\nexports.strToChars = function (str) {\n  /* jshint maxlen: false */\n  var chars_regex = /(\\[\\\\b\\])|(\\\\)?\\\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z\\[\\\\\\]\\^?])|([0tnvfr]))/g;\n  str = str.replace(chars_regex, function (s, b, lbs, a16, b16, c8, dctrl, eslsh) {\n    if (lbs) {\n      return s;\n    }\n\n    var code = b ? 8 : a16 ? parseInt(a16, 16) : b16 ? parseInt(b16, 16) : c8 ? parseInt(c8, 8) : dctrl ? CTRL.indexOf(dctrl) : SLSH[eslsh];\n    var c = String.fromCharCode(code); // Escape special regex characters.\n\n    if (/[\\[\\]{}\\^$.|?*+()]/.test(c)) {\n      c = '\\\\' + c;\n    }\n\n    return c;\n  });\n  return str;\n};\n/**\r\n * turns class into tokens\r\n * reads str until it encounters a ] not preceeded by a \\\r\n *\r\n * @param {String} str\r\n * @param {String} regexpStr\r\n * @return {Array.<Array.<Object>, Number>}\r\n */\n\n\nexports.tokenizeClass = function (str, regexpStr) {\n  /* jshint maxlen: false */\n  var tokens = [];\n  var regexp = /\\\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\\\)(.)|([^\\]\\\\]))-(?:\\\\)?([^\\]]))|(\\])|(?:\\\\)?(.)/g;\n  var rs, c;\n\n  while ((rs = regexp.exec(str)) != null) {\n    if (rs[1]) {\n      tokens.push(sets.words());\n    } else if (rs[2]) {\n      tokens.push(sets.ints());\n    } else if (rs[3]) {\n      tokens.push(sets.whitespace());\n    } else if (rs[4]) {\n      tokens.push(sets.notWords());\n    } else if (rs[5]) {\n      tokens.push(sets.notInts());\n    } else if (rs[6]) {\n      tokens.push(sets.notWhitespace());\n    } else if (rs[7]) {\n      tokens.push({\n        type: types.RANGE,\n        from: (rs[8] || rs[9]).charCodeAt(0),\n        to: rs[10].charCodeAt(0)\n      });\n    } else if (c = rs[12]) {\n      tokens.push({\n        type: types.CHAR,\n        value: c.charCodeAt(0)\n      });\n    } else {\n      return [tokens, regexp.lastIndex];\n    }\n  }\n\n  exports.error(regexpStr, 'Unterminated character class');\n};\n/**\r\n * Shortcut to throw errors.\r\n *\r\n * @param {String} regexp\r\n * @param {String} msg\r\n */\n\n\nexports.error = function (regexp, msg) {\n  throw new SyntaxError('Invalid regular expression: /' + regexp + '/: ' + msg);\n};","map":{"version":3,"sources":["C:/frontend/node_modules/ret/lib/util.js"],"names":["types","require","sets","CTRL","SLSH","exports","strToChars","str","chars_regex","replace","s","b","lbs","a16","b16","c8","dctrl","eslsh","code","parseInt","indexOf","c","String","fromCharCode","test","tokenizeClass","regexpStr","tokens","regexp","rs","exec","push","words","ints","whitespace","notWords","notInts","notWhitespace","type","RANGE","from","charCodeAt","to","CHAR","value","lastIndex","error","msg","SyntaxError"],"mappings":"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","sourcesContent":["var types = require('./types');\r\nvar sets  = require('./sets');\r\n\r\n\r\n// All of these are private and only used by randexp.\r\n// It's assumed that they will always be called with the correct input.\r\n\r\nvar CTRL = '@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^ ?';\r\nvar SLSH = { '0': 0, 't': 9, 'n': 10, 'v': 11, 'f': 12, 'r': 13 };\r\n\r\n/**\r\n * Finds character representations in str and convert all to\r\n * their respective characters\r\n *\r\n * @param {String} str\r\n * @return {String}\r\n */\r\nexports.strToChars = function(str) {\r\n  /* jshint maxlen: false */\r\n  var chars_regex = /(\\[\\\\b\\])|(\\\\)?\\\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z\\[\\\\\\]\\^?])|([0tnvfr]))/g;\r\n  str = str.replace(chars_regex, function(s, b, lbs, a16, b16, c8, dctrl, eslsh) {\r\n    if (lbs) {\r\n      return s;\r\n    }\r\n\r\n    var code = b     ? 8 :\r\n               a16   ? parseInt(a16, 16) :\r\n               b16   ? parseInt(b16, 16) :\r\n               c8    ? parseInt(c8,   8) :\r\n               dctrl ? CTRL.indexOf(dctrl) :\r\n               SLSH[eslsh];\r\n\r\n    var c = String.fromCharCode(code);\r\n\r\n    // Escape special regex characters.\r\n    if (/[\\[\\]{}\\^$.|?*+()]/.test(c)) {\r\n      c = '\\\\' + c;\r\n    }\r\n\r\n    return c;\r\n  });\r\n\r\n  return str;\r\n};\r\n\r\n\r\n/**\r\n * turns class into tokens\r\n * reads str until it encounters a ] not preceeded by a \\\r\n *\r\n * @param {String} str\r\n * @param {String} regexpStr\r\n * @return {Array.<Array.<Object>, Number>}\r\n */\r\nexports.tokenizeClass = function(str, regexpStr) {\r\n  /* jshint maxlen: false */\r\n  var tokens = [];\r\n  var regexp = /\\\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\\\)(.)|([^\\]\\\\]))-(?:\\\\)?([^\\]]))|(\\])|(?:\\\\)?(.)/g;\r\n  var rs, c;\r\n\r\n\r\n  while ((rs = regexp.exec(str)) != null) {\r\n    if (rs[1]) {\r\n      tokens.push(sets.words());\r\n\r\n    } else if (rs[2]) {\r\n      tokens.push(sets.ints());\r\n\r\n    } else if (rs[3]) {\r\n      tokens.push(sets.whitespace());\r\n\r\n    } else if (rs[4]) {\r\n      tokens.push(sets.notWords());\r\n\r\n    } else if (rs[5]) {\r\n      tokens.push(sets.notInts());\r\n\r\n    } else if (rs[6]) {\r\n      tokens.push(sets.notWhitespace());\r\n\r\n    } else if (rs[7]) {\r\n      tokens.push({\r\n        type: types.RANGE,\r\n        from: (rs[8] || rs[9]).charCodeAt(0),\r\n          to: rs[10].charCodeAt(0),\r\n      });\r\n\r\n    } else if (c = rs[12]) {\r\n      tokens.push({\r\n        type: types.CHAR,\r\n        value: c.charCodeAt(0),\r\n      });\r\n\r\n    } else {\r\n      return [tokens, regexp.lastIndex];\r\n    }\r\n  }\r\n\r\n  exports.error(regexpStr, 'Unterminated character class');\r\n};\r\n\r\n\r\n/**\r\n * Shortcut to throw errors.\r\n *\r\n * @param {String} regexp\r\n * @param {String} msg\r\n */\r\nexports.error = function(regexp, msg) {\r\n  throw new SyntaxError('Invalid regular expression: /' + regexp + '/: ' + msg);\r\n};\r\n"]},"metadata":{},"sourceType":"script"}