{"ast":null,"code":"'use strict';\n/**\r\n * Module dependencies\r\n */\n\nvar toRegex = require('to-regex');\n\nvar unique = require('array-unique');\n\nvar extend = require('extend-shallow');\n/**\r\n * Local dependencies\r\n */\n\n\nvar compilers = require('./lib/compilers');\n\nvar parsers = require('./lib/parsers');\n\nvar Braces = require('./lib/braces');\n\nvar utils = require('./lib/utils');\n\nvar MAX_LENGTH = 1024 * 64;\nvar cache = {};\n/**\r\n * Convert the given `braces` pattern into a regex-compatible string. By default, only one string is generated for every input string. Set `options.expand` to true to return an array of patterns (similar to Bash or minimatch. Before using `options.expand`, it's recommended that you read the [performance notes](#performance)).\r\n *\r\n * ```js\r\n * var braces = require('braces');\r\n * console.log(braces('{a,b,c}'));\r\n * //=> ['(a|b|c)']\r\n *\r\n * console.log(braces('{a,b,c}', {expand: true}));\r\n * //=> ['a', 'b', 'c']\r\n * ```\r\n * @param {String} `str`\r\n * @param {Object} `options`\r\n * @return {String}\r\n * @api public\r\n */\n\nfunction braces(pattern, options) {\n  var key = utils.createKey(String(pattern), options);\n  var arr = [];\n  var disabled = options && options.cache === false;\n\n  if (!disabled && cache.hasOwnProperty(key)) {\n    return cache[key];\n  }\n\n  if (Array.isArray(pattern)) {\n    for (var i = 0; i < pattern.length; i++) {\n      arr.push.apply(arr, braces.create(pattern[i], options));\n    }\n  } else {\n    arr = braces.create(pattern, options);\n  }\n\n  if (options && options.nodupes === true) {\n    arr = unique(arr);\n  }\n\n  if (!disabled) {\n    cache[key] = arr;\n  }\n\n  return arr;\n}\n/**\r\n * Expands a brace pattern into an array. This method is called by the main [braces](#braces) function when `options.expand` is true. Before using this method it's recommended that you read the [performance notes](#performance)) and advantages of using [.optimize](#optimize) instead.\r\n *\r\n * ```js\r\n * var braces = require('braces');\r\n * console.log(braces.expand('a/{b,c}/d'));\r\n * //=> ['a/b/d', 'a/c/d'];\r\n * ```\r\n * @param {String} `pattern` Brace pattern\r\n * @param {Object} `options`\r\n * @return {Array} Returns an array of expanded values.\r\n * @api public\r\n */\n\n\nbraces.expand = function (pattern, options) {\n  return braces.create(pattern, extend({}, options, {\n    expand: true\n  }));\n};\n/**\r\n * Expands a brace pattern into a regex-compatible, optimized string. This method is called by the main [braces](#braces) function by default.\r\n *\r\n * ```js\r\n * var braces = require('braces');\r\n * console.log(braces.expand('a/{b,c}/d'));\r\n * //=> ['a/(b|c)/d']\r\n * ```\r\n * @param {String} `pattern` Brace pattern\r\n * @param {Object} `options`\r\n * @return {Array} Returns an array of expanded values.\r\n * @api public\r\n */\n\n\nbraces.optimize = function (pattern, options) {\n  return braces.create(pattern, options);\n};\n/**\r\n * Processes a brace pattern and returns either an expanded array (if `options.expand` is true), a highly optimized regex-compatible string. This method is called by the main [braces](#braces) function.\r\n *\r\n * ```js\r\n * var braces = require('braces');\r\n * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\r\n * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\r\n * ```\r\n * @param {String} `pattern` Brace pattern\r\n * @param {Object} `options`\r\n * @return {Array} Returns an array of expanded values.\r\n * @api public\r\n */\n\n\nbraces.create = function (pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected a string');\n  }\n\n  var maxLength = options && options.maxLength || MAX_LENGTH;\n\n  if (pattern.length >= maxLength) {\n    throw new Error('expected pattern to be less than ' + maxLength + ' characters');\n  }\n\n  function create() {\n    if (pattern === '' || pattern.length < 3) {\n      return [pattern];\n    }\n\n    if (utils.isEmptySets(pattern)) {\n      return [];\n    }\n\n    if (utils.isQuotedString(pattern)) {\n      return [pattern.slice(1, -1)];\n    }\n\n    var proto = new Braces(options);\n    var result = !options || options.expand !== true ? proto.optimize(pattern, options) : proto.expand(pattern, options); // get the generated pattern(s)\n\n    var arr = result.output; // filter out empty strings if specified\n\n    if (options && options.noempty === true) {\n      arr = arr.filter(Boolean);\n    } // filter out duplicates if specified\n\n\n    if (options && options.nodupes === true) {\n      arr = unique(arr);\n    }\n\n    Object.defineProperty(arr, 'result', {\n      enumerable: false,\n      value: result\n    });\n    return arr;\n  }\n\n  return memoize('create', pattern, options, create);\n};\n/**\r\n * Create a regular expression from the given string `pattern`.\r\n *\r\n * ```js\r\n * var braces = require('braces');\r\n *\r\n * console.log(braces.makeRe('id-{200..300}'));\r\n * //=> /^(?:id-(20[0-9]|2[1-9][0-9]|300))$/\r\n * ```\r\n * @param {String} `pattern` The pattern to convert to regex.\r\n * @param {Object} `options`\r\n * @return {RegExp}\r\n * @api public\r\n */\n\n\nbraces.makeRe = function (pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected a string');\n  }\n\n  var maxLength = options && options.maxLength || MAX_LENGTH;\n\n  if (pattern.length >= maxLength) {\n    throw new Error('expected pattern to be less than ' + maxLength + ' characters');\n  }\n\n  function makeRe() {\n    var arr = braces(pattern, options);\n    var opts = extend({\n      strictErrors: false\n    }, options);\n    return toRegex(arr, opts);\n  }\n\n  return memoize('makeRe', pattern, options, makeRe);\n};\n/**\r\n * Parse the given `str` with the given `options`.\r\n *\r\n * ```js\r\n * var braces = require('braces');\r\n * var ast = braces.parse('a/{b,c}/d');\r\n * console.log(ast);\r\n * // { type: 'root',\r\n * //   errors: [],\r\n * //   input: 'a/{b,c}/d',\r\n * //   nodes:\r\n * //    [ { type: 'bos', val: '' },\r\n * //      { type: 'text', val: 'a/' },\r\n * //      { type: 'brace',\r\n * //        nodes:\r\n * //         [ { type: 'brace.open', val: '{' },\r\n * //           { type: 'text', val: 'b,c' },\r\n * //           { type: 'brace.close', val: '}' } ] },\r\n * //      { type: 'text', val: '/d' },\r\n * //      { type: 'eos', val: '' } ] }\r\n * ```\r\n * @param {String} `pattern` Brace pattern to parse\r\n * @param {Object} `options`\r\n * @return {Object} Returns an AST\r\n * @api public\r\n */\n\n\nbraces.parse = function (pattern, options) {\n  var proto = new Braces(options);\n  return proto.parse(pattern, options);\n};\n/**\r\n * Compile the given `ast` or string with the given `options`.\r\n *\r\n * ```js\r\n * var braces = require('braces');\r\n * var ast = braces.parse('a/{b,c}/d');\r\n * console.log(braces.compile(ast));\r\n * // { options: { source: 'string' },\r\n * //   state: {},\r\n * //   compilers:\r\n * //    { eos: [Function],\r\n * //      noop: [Function],\r\n * //      bos: [Function],\r\n * //      brace: [Function],\r\n * //      'brace.open': [Function],\r\n * //      text: [Function],\r\n * //      'brace.close': [Function] },\r\n * //   output: [ 'a/(b|c)/d' ],\r\n * //   ast:\r\n * //    { ... },\r\n * //   parsingErrors: [] }\r\n * ```\r\n * @param {Object|String} `ast` AST from [.parse](#parse). If a string is passed it will be parsed first.\r\n * @param {Object} `options`\r\n * @return {Object} Returns an object that has an `output` property with the compiled string.\r\n * @api public\r\n */\n\n\nbraces.compile = function (ast, options) {\n  var proto = new Braces(options);\n  return proto.compile(ast, options);\n};\n/**\r\n * Clear the regex cache.\r\n *\r\n * ```js\r\n * braces.clearCache();\r\n * ```\r\n * @api public\r\n */\n\n\nbraces.clearCache = function () {\n  cache = braces.cache = {};\n};\n/**\r\n * Memoize a generated regex or function. A unique key is generated\r\n * from the method name, pattern, and user-defined options. Set\r\n * options.memoize to false to disable.\r\n */\n\n\nfunction memoize(type, pattern, options, fn) {\n  var key = utils.createKey(type + ':' + pattern, options);\n  var disabled = options && options.cache === false;\n\n  if (disabled) {\n    braces.clearCache();\n    return fn(pattern, options);\n  }\n\n  if (cache.hasOwnProperty(key)) {\n    return cache[key];\n  }\n\n  var res = fn(pattern, options);\n  cache[key] = res;\n  return res;\n}\n/**\r\n * Expose `Braces` constructor and methods\r\n * @type {Function}\r\n */\n\n\nbraces.Braces = Braces;\nbraces.compilers = compilers;\nbraces.parsers = parsers;\nbraces.cache = cache;\n/**\r\n * Expose `braces`\r\n * @type {Function}\r\n */\n\nmodule.exports = braces;","map":{"version":3,"sources":["C:/frontend/node_modules/braces/index.js"],"names":["toRegex","require","unique","extend","compilers","parsers","Braces","utils","MAX_LENGTH","cache","braces","pattern","options","key","createKey","String","arr","disabled","hasOwnProperty","Array","isArray","i","length","push","apply","create","nodupes","expand","optimize","TypeError","maxLength","Error","isEmptySets","isQuotedString","slice","proto","result","output","noempty","filter","Boolean","Object","defineProperty","enumerable","value","memoize","makeRe","opts","strictErrors","parse","compile","ast","clearCache","type","fn","res","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\n/**\r\n * Module dependencies\r\n */\r\n\r\nvar toRegex = require('to-regex');\r\nvar unique = require('array-unique');\r\nvar extend = require('extend-shallow');\r\n\r\n/**\r\n * Local dependencies\r\n */\r\n\r\nvar compilers = require('./lib/compilers');\r\nvar parsers = require('./lib/parsers');\r\nvar Braces = require('./lib/braces');\r\nvar utils = require('./lib/utils');\r\nvar MAX_LENGTH = 1024 * 64;\r\nvar cache = {};\r\n\r\n/**\r\n * Convert the given `braces` pattern into a regex-compatible string. By default, only one string is generated for every input string. Set `options.expand` to true to return an array of patterns (similar to Bash or minimatch. Before using `options.expand`, it's recommended that you read the [performance notes](#performance)).\r\n *\r\n * ```js\r\n * var braces = require('braces');\r\n * console.log(braces('{a,b,c}'));\r\n * //=> ['(a|b|c)']\r\n *\r\n * console.log(braces('{a,b,c}', {expand: true}));\r\n * //=> ['a', 'b', 'c']\r\n * ```\r\n * @param {String} `str`\r\n * @param {Object} `options`\r\n * @return {String}\r\n * @api public\r\n */\r\n\r\nfunction braces(pattern, options) {\r\n  var key = utils.createKey(String(pattern), options);\r\n  var arr = [];\r\n\r\n  var disabled = options && options.cache === false;\r\n  if (!disabled && cache.hasOwnProperty(key)) {\r\n    return cache[key];\r\n  }\r\n\r\n  if (Array.isArray(pattern)) {\r\n    for (var i = 0; i < pattern.length; i++) {\r\n      arr.push.apply(arr, braces.create(pattern[i], options));\r\n    }\r\n  } else {\r\n    arr = braces.create(pattern, options);\r\n  }\r\n\r\n  if (options && options.nodupes === true) {\r\n    arr = unique(arr);\r\n  }\r\n\r\n  if (!disabled) {\r\n    cache[key] = arr;\r\n  }\r\n  return arr;\r\n}\r\n\r\n/**\r\n * Expands a brace pattern into an array. This method is called by the main [braces](#braces) function when `options.expand` is true. Before using this method it's recommended that you read the [performance notes](#performance)) and advantages of using [.optimize](#optimize) instead.\r\n *\r\n * ```js\r\n * var braces = require('braces');\r\n * console.log(braces.expand('a/{b,c}/d'));\r\n * //=> ['a/b/d', 'a/c/d'];\r\n * ```\r\n * @param {String} `pattern` Brace pattern\r\n * @param {Object} `options`\r\n * @return {Array} Returns an array of expanded values.\r\n * @api public\r\n */\r\n\r\nbraces.expand = function(pattern, options) {\r\n  return braces.create(pattern, extend({}, options, {expand: true}));\r\n};\r\n\r\n/**\r\n * Expands a brace pattern into a regex-compatible, optimized string. This method is called by the main [braces](#braces) function by default.\r\n *\r\n * ```js\r\n * var braces = require('braces');\r\n * console.log(braces.expand('a/{b,c}/d'));\r\n * //=> ['a/(b|c)/d']\r\n * ```\r\n * @param {String} `pattern` Brace pattern\r\n * @param {Object} `options`\r\n * @return {Array} Returns an array of expanded values.\r\n * @api public\r\n */\r\n\r\nbraces.optimize = function(pattern, options) {\r\n  return braces.create(pattern, options);\r\n};\r\n\r\n/**\r\n * Processes a brace pattern and returns either an expanded array (if `options.expand` is true), a highly optimized regex-compatible string. This method is called by the main [braces](#braces) function.\r\n *\r\n * ```js\r\n * var braces = require('braces');\r\n * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\r\n * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\r\n * ```\r\n * @param {String} `pattern` Brace pattern\r\n * @param {Object} `options`\r\n * @return {Array} Returns an array of expanded values.\r\n * @api public\r\n */\r\n\r\nbraces.create = function(pattern, options) {\r\n  if (typeof pattern !== 'string') {\r\n    throw new TypeError('expected a string');\r\n  }\r\n\r\n  var maxLength = (options && options.maxLength) || MAX_LENGTH;\r\n  if (pattern.length >= maxLength) {\r\n    throw new Error('expected pattern to be less than ' + maxLength + ' characters');\r\n  }\r\n\r\n  function create() {\r\n    if (pattern === '' || pattern.length < 3) {\r\n      return [pattern];\r\n    }\r\n\r\n    if (utils.isEmptySets(pattern)) {\r\n      return [];\r\n    }\r\n\r\n    if (utils.isQuotedString(pattern)) {\r\n      return [pattern.slice(1, -1)];\r\n    }\r\n\r\n    var proto = new Braces(options);\r\n    var result = !options || options.expand !== true\r\n      ? proto.optimize(pattern, options)\r\n      : proto.expand(pattern, options);\r\n\r\n    // get the generated pattern(s)\r\n    var arr = result.output;\r\n\r\n    // filter out empty strings if specified\r\n    if (options && options.noempty === true) {\r\n      arr = arr.filter(Boolean);\r\n    }\r\n\r\n    // filter out duplicates if specified\r\n    if (options && options.nodupes === true) {\r\n      arr = unique(arr);\r\n    }\r\n\r\n    Object.defineProperty(arr, 'result', {\r\n      enumerable: false,\r\n      value: result\r\n    });\r\n\r\n    return arr;\r\n  }\r\n\r\n  return memoize('create', pattern, options, create);\r\n};\r\n\r\n/**\r\n * Create a regular expression from the given string `pattern`.\r\n *\r\n * ```js\r\n * var braces = require('braces');\r\n *\r\n * console.log(braces.makeRe('id-{200..300}'));\r\n * //=> /^(?:id-(20[0-9]|2[1-9][0-9]|300))$/\r\n * ```\r\n * @param {String} `pattern` The pattern to convert to regex.\r\n * @param {Object} `options`\r\n * @return {RegExp}\r\n * @api public\r\n */\r\n\r\nbraces.makeRe = function(pattern, options) {\r\n  if (typeof pattern !== 'string') {\r\n    throw new TypeError('expected a string');\r\n  }\r\n\r\n  var maxLength = (options && options.maxLength) || MAX_LENGTH;\r\n  if (pattern.length >= maxLength) {\r\n    throw new Error('expected pattern to be less than ' + maxLength + ' characters');\r\n  }\r\n\r\n  function makeRe() {\r\n    var arr = braces(pattern, options);\r\n    var opts = extend({strictErrors: false}, options);\r\n    return toRegex(arr, opts);\r\n  }\r\n\r\n  return memoize('makeRe', pattern, options, makeRe);\r\n};\r\n\r\n/**\r\n * Parse the given `str` with the given `options`.\r\n *\r\n * ```js\r\n * var braces = require('braces');\r\n * var ast = braces.parse('a/{b,c}/d');\r\n * console.log(ast);\r\n * // { type: 'root',\r\n * //   errors: [],\r\n * //   input: 'a/{b,c}/d',\r\n * //   nodes:\r\n * //    [ { type: 'bos', val: '' },\r\n * //      { type: 'text', val: 'a/' },\r\n * //      { type: 'brace',\r\n * //        nodes:\r\n * //         [ { type: 'brace.open', val: '{' },\r\n * //           { type: 'text', val: 'b,c' },\r\n * //           { type: 'brace.close', val: '}' } ] },\r\n * //      { type: 'text', val: '/d' },\r\n * //      { type: 'eos', val: '' } ] }\r\n * ```\r\n * @param {String} `pattern` Brace pattern to parse\r\n * @param {Object} `options`\r\n * @return {Object} Returns an AST\r\n * @api public\r\n */\r\n\r\nbraces.parse = function(pattern, options) {\r\n  var proto = new Braces(options);\r\n  return proto.parse(pattern, options);\r\n};\r\n\r\n/**\r\n * Compile the given `ast` or string with the given `options`.\r\n *\r\n * ```js\r\n * var braces = require('braces');\r\n * var ast = braces.parse('a/{b,c}/d');\r\n * console.log(braces.compile(ast));\r\n * // { options: { source: 'string' },\r\n * //   state: {},\r\n * //   compilers:\r\n * //    { eos: [Function],\r\n * //      noop: [Function],\r\n * //      bos: [Function],\r\n * //      brace: [Function],\r\n * //      'brace.open': [Function],\r\n * //      text: [Function],\r\n * //      'brace.close': [Function] },\r\n * //   output: [ 'a/(b|c)/d' ],\r\n * //   ast:\r\n * //    { ... },\r\n * //   parsingErrors: [] }\r\n * ```\r\n * @param {Object|String} `ast` AST from [.parse](#parse). If a string is passed it will be parsed first.\r\n * @param {Object} `options`\r\n * @return {Object} Returns an object that has an `output` property with the compiled string.\r\n * @api public\r\n */\r\n\r\nbraces.compile = function(ast, options) {\r\n  var proto = new Braces(options);\r\n  return proto.compile(ast, options);\r\n};\r\n\r\n/**\r\n * Clear the regex cache.\r\n *\r\n * ```js\r\n * braces.clearCache();\r\n * ```\r\n * @api public\r\n */\r\n\r\nbraces.clearCache = function() {\r\n  cache = braces.cache = {};\r\n};\r\n\r\n/**\r\n * Memoize a generated regex or function. A unique key is generated\r\n * from the method name, pattern, and user-defined options. Set\r\n * options.memoize to false to disable.\r\n */\r\n\r\nfunction memoize(type, pattern, options, fn) {\r\n  var key = utils.createKey(type + ':' + pattern, options);\r\n  var disabled = options && options.cache === false;\r\n  if (disabled) {\r\n    braces.clearCache();\r\n    return fn(pattern, options);\r\n  }\r\n\r\n  if (cache.hasOwnProperty(key)) {\r\n    return cache[key];\r\n  }\r\n\r\n  var res = fn(pattern, options);\r\n  cache[key] = res;\r\n  return res;\r\n}\r\n\r\n/**\r\n * Expose `Braces` constructor and methods\r\n * @type {Function}\r\n */\r\n\r\nbraces.Braces = Braces;\r\nbraces.compilers = compilers;\r\nbraces.parsers = parsers;\r\nbraces.cache = cache;\r\n\r\n/**\r\n * Expose `braces`\r\n * @type {Function}\r\n */\r\n\r\nmodule.exports = braces;\r\n"]},"metadata":{},"sourceType":"script"}