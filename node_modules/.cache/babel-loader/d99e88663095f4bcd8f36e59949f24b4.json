{"ast":null,"code":"'use strict';\n\nvar regex = require('regex-not');\n\nvar Cache = require('fragment-cache');\n/**\r\n * Utils\r\n */\n\n\nvar utils = module.exports;\nvar cache = utils.cache = new Cache();\n/**\r\n * Cast `val` to an array\r\n * @return {Array}\r\n */\n\nutils.arrayify = function (val) {\n  if (!Array.isArray(val)) {\n    return [val];\n  }\n\n  return val;\n};\n/**\r\n * Memoize a generated regex or function\r\n */\n\n\nutils.memoize = function (type, pattern, options, fn) {\n  var key = utils.createKey(type + pattern, options);\n\n  if (cache.has(type, key)) {\n    return cache.get(type, key);\n  }\n\n  var val = fn(pattern, options);\n\n  if (options && options.cache === false) {\n    return val;\n  }\n\n  cache.set(type, key, val);\n  return val;\n};\n/**\r\n * Create the key to use for memoization. The key is generated\r\n * by iterating over the options and concatenating key-value pairs\r\n * to the pattern string.\r\n */\n\n\nutils.createKey = function (pattern, options) {\n  var key = pattern;\n\n  if (typeof options === 'undefined') {\n    return key;\n  }\n\n  for (var prop in options) {\n    key += ';' + prop + '=' + String(options[prop]);\n  }\n\n  return key;\n};\n/**\r\n * Create the regex to use for matching text\r\n */\n\n\nutils.createRegex = function (str) {\n  var opts = {\n    contains: true,\n    strictClose: false\n  };\n  return regex(str, opts);\n};","map":{"version":3,"sources":["C:/frontend/node_modules/extglob/lib/utils.js"],"names":["regex","require","Cache","utils","module","exports","cache","arrayify","val","Array","isArray","memoize","type","pattern","options","fn","key","createKey","has","get","set","prop","String","createRegex","str","opts","contains","strictClose"],"mappings":"AAAA;;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAC,WAAD,CAAnB;;AACA,IAAIC,KAAK,GAAGD,OAAO,CAAC,gBAAD,CAAnB;AAEA;AACA;AACA;;;AAEA,IAAIE,KAAK,GAAGC,MAAM,CAACC,OAAnB;AACA,IAAIC,KAAK,GAAGH,KAAK,CAACG,KAAN,GAAc,IAAIJ,KAAJ,EAA1B;AAEA;AACA;AACA;AACA;;AAEAC,KAAK,CAACI,QAAN,GAAiB,UAASC,GAAT,EAAc;AAC7B,MAAI,CAACC,KAAK,CAACC,OAAN,CAAcF,GAAd,CAAL,EAAyB;AACvB,WAAO,CAACA,GAAD,CAAP;AACD;;AACD,SAAOA,GAAP;AACD,CALD;AAOA;AACA;AACA;;;AAEAL,KAAK,CAACQ,OAAN,GAAgB,UAASC,IAAT,EAAeC,OAAf,EAAwBC,OAAxB,EAAiCC,EAAjC,EAAqC;AACnD,MAAIC,GAAG,GAAGb,KAAK,CAACc,SAAN,CAAgBL,IAAI,GAAGC,OAAvB,EAAgCC,OAAhC,CAAV;;AAEA,MAAIR,KAAK,CAACY,GAAN,CAAUN,IAAV,EAAgBI,GAAhB,CAAJ,EAA0B;AACxB,WAAOV,KAAK,CAACa,GAAN,CAAUP,IAAV,EAAgBI,GAAhB,CAAP;AACD;;AAED,MAAIR,GAAG,GAAGO,EAAE,CAACF,OAAD,EAAUC,OAAV,CAAZ;;AACA,MAAIA,OAAO,IAAIA,OAAO,CAACR,KAAR,KAAkB,KAAjC,EAAwC;AACtC,WAAOE,GAAP;AACD;;AAEDF,EAAAA,KAAK,CAACc,GAAN,CAAUR,IAAV,EAAgBI,GAAhB,EAAqBR,GAArB;AACA,SAAOA,GAAP;AACD,CAdD;AAgBA;AACA;AACA;AACA;AACA;;;AAEAL,KAAK,CAACc,SAAN,GAAkB,UAASJ,OAAT,EAAkBC,OAAlB,EAA2B;AAC3C,MAAIE,GAAG,GAAGH,OAAV;;AACA,MAAI,OAAOC,OAAP,KAAmB,WAAvB,EAAoC;AAClC,WAAOE,GAAP;AACD;;AACD,OAAK,IAAIK,IAAT,IAAiBP,OAAjB,EAA0B;AACxBE,IAAAA,GAAG,IAAI,MAAMK,IAAN,GAAa,GAAb,GAAmBC,MAAM,CAACR,OAAO,CAACO,IAAD,CAAR,CAAhC;AACD;;AACD,SAAOL,GAAP;AACD,CATD;AAWA;AACA;AACA;;;AAEAb,KAAK,CAACoB,WAAN,GAAoB,UAASC,GAAT,EAAc;AAChC,MAAIC,IAAI,GAAG;AAACC,IAAAA,QAAQ,EAAE,IAAX;AAAiBC,IAAAA,WAAW,EAAE;AAA9B,GAAX;AACA,SAAO3B,KAAK,CAACwB,GAAD,EAAMC,IAAN,CAAZ;AACD,CAHD","sourcesContent":["'use strict';\r\n\r\nvar regex = require('regex-not');\r\nvar Cache = require('fragment-cache');\r\n\r\n/**\r\n * Utils\r\n */\r\n\r\nvar utils = module.exports;\r\nvar cache = utils.cache = new Cache();\r\n\r\n/**\r\n * Cast `val` to an array\r\n * @return {Array}\r\n */\r\n\r\nutils.arrayify = function(val) {\r\n  if (!Array.isArray(val)) {\r\n    return [val];\r\n  }\r\n  return val;\r\n};\r\n\r\n/**\r\n * Memoize a generated regex or function\r\n */\r\n\r\nutils.memoize = function(type, pattern, options, fn) {\r\n  var key = utils.createKey(type + pattern, options);\r\n\r\n  if (cache.has(type, key)) {\r\n    return cache.get(type, key);\r\n  }\r\n\r\n  var val = fn(pattern, options);\r\n  if (options && options.cache === false) {\r\n    return val;\r\n  }\r\n\r\n  cache.set(type, key, val);\r\n  return val;\r\n};\r\n\r\n/**\r\n * Create the key to use for memoization. The key is generated\r\n * by iterating over the options and concatenating key-value pairs\r\n * to the pattern string.\r\n */\r\n\r\nutils.createKey = function(pattern, options) {\r\n  var key = pattern;\r\n  if (typeof options === 'undefined') {\r\n    return key;\r\n  }\r\n  for (var prop in options) {\r\n    key += ';' + prop + '=' + String(options[prop]);\r\n  }\r\n  return key;\r\n};\r\n\r\n/**\r\n * Create the regex to use for matching text\r\n */\r\n\r\nutils.createRegex = function(str) {\r\n  var opts = {contains: true, strictClose: false};\r\n  return regex(str, opts);\r\n};\r\n"]},"metadata":{},"sourceType":"script"}