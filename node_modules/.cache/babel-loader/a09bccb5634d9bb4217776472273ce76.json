{"ast":null,"code":"'use strict';\n\nvar utils = module.exports;\n\nvar path = require('path');\n/**\r\n * Module dependencies\r\n */\n\n\nvar Snapdragon = require('snapdragon');\n\nutils.define = require('define-property');\nutils.diff = require('arr-diff');\nutils.extend = require('extend-shallow');\nutils.pick = require('object.pick');\nutils.typeOf = require('kind-of');\nutils.unique = require('array-unique');\n/**\r\n * Returns true if the platform is windows, or `path.sep` is `\\\\`.\r\n * This is defined as a function to allow `path.sep` to be set in unit tests,\r\n * or by the user, if there is a reason to do so.\r\n * @return {Boolean}\r\n */\n\nutils.isWindows = function () {\n  return path.sep === '\\\\' || process.platform === 'win32';\n};\n/**\r\n * Get the `Snapdragon` instance to use\r\n */\n\n\nutils.instantiate = function (ast, options) {\n  var snapdragon; // if an instance was created by `.parse`, use that instance\n\n  if (utils.typeOf(ast) === 'object' && ast.snapdragon) {\n    snapdragon = ast.snapdragon; // if the user supplies an instance on options, use that instance\n  } else if (utils.typeOf(options) === 'object' && options.snapdragon) {\n    snapdragon = options.snapdragon; // create a new instance\n  } else {\n    snapdragon = new Snapdragon(options);\n  }\n\n  utils.define(snapdragon, 'parse', function (str, options) {\n    var parsed = Snapdragon.prototype.parse.apply(this, arguments);\n    parsed.input = str; // escape unmatched brace/bracket/parens\n\n    var last = this.parser.stack.pop();\n\n    if (last && this.options.strictErrors !== true) {\n      var open = last.nodes[0];\n      var inner = last.nodes[1];\n\n      if (last.type === 'bracket') {\n        if (inner.val.charAt(0) === '[') {\n          inner.val = '\\\\' + inner.val;\n        }\n      } else {\n        open.val = '\\\\' + open.val;\n        var sibling = open.parent.nodes[1];\n\n        if (sibling.type === 'star') {\n          sibling.loose = true;\n        }\n      }\n    } // add non-enumerable parser reference\n\n\n    utils.define(parsed, 'parser', this.parser);\n    return parsed;\n  });\n  return snapdragon;\n};\n/**\r\n * Create the key to use for memoization. The key is generated\r\n * by iterating over the options and concatenating key-value pairs\r\n * to the pattern string.\r\n */\n\n\nutils.createKey = function (pattern, options) {\n  if (utils.typeOf(options) !== 'object') {\n    return pattern;\n  }\n\n  var val = pattern;\n  var keys = Object.keys(options);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    val += ';' + key + '=' + String(options[key]);\n  }\n\n  return val;\n};\n/**\r\n * Cast `val` to an array\r\n * @return {Array}\r\n */\n\n\nutils.arrayify = function (val) {\n  if (typeof val === 'string') return [val];\n  return val ? Array.isArray(val) ? val : [val] : [];\n};\n/**\r\n * Return true if `val` is a non-empty string\r\n */\n\n\nutils.isString = function (val) {\n  return typeof val === 'string';\n};\n/**\r\n * Return true if `val` is a non-empty string\r\n */\n\n\nutils.isObject = function (val) {\n  return utils.typeOf(val) === 'object';\n};\n/**\r\n * Returns true if the given `str` has special characters\r\n */\n\n\nutils.hasSpecialChars = function (str) {\n  return /(?:(?:(^|\\/)[!.])|[*?+()|\\[\\]{}]|[+@]\\()/.test(str);\n};\n/**\r\n * Escape regex characters in the given string\r\n */\n\n\nutils.escapeRegex = function (str) {\n  return str.replace(/[-[\\]{}()^$|*+?.\\\\\\/\\s]/g, '\\\\$&');\n};\n/**\r\n * Normalize slashes in the given filepath.\r\n *\r\n * @param {String} `filepath`\r\n * @return {String}\r\n */\n\n\nutils.toPosixPath = function (str) {\n  return str.replace(/\\\\+/g, '/');\n};\n/**\r\n * Strip backslashes before special characters in a string.\r\n *\r\n * @param {String} `str`\r\n * @return {String}\r\n */\n\n\nutils.unescape = function (str) {\n  return utils.toPosixPath(str.replace(/\\\\(?=[*+?!.])/g, ''));\n};\n/**\r\n * Strip the prefix from a filepath\r\n * @param {String} `fp`\r\n * @return {String}\r\n */\n\n\nutils.stripPrefix = function (str) {\n  if (str.charAt(0) !== '.') {\n    return str;\n  }\n\n  var ch = str.charAt(1);\n\n  if (utils.isSlash(ch)) {\n    return str.slice(2);\n  }\n\n  return str;\n};\n/**\r\n * Returns true if the given str is an escaped or\r\n * unescaped path character\r\n */\n\n\nutils.isSlash = function (str) {\n  return str === '/' || str === '\\\\/' || str === '\\\\' || str === '\\\\\\\\';\n};\n/**\r\n * Returns a function that returns true if the given\r\n * pattern matches or contains a `filepath`\r\n *\r\n * @param {String} `pattern`\r\n * @return {Function}\r\n */\n\n\nutils.matchPath = function (pattern, options) {\n  return options && options.contains ? utils.containsPattern(pattern, options) : utils.equalsPattern(pattern, options);\n};\n/**\r\n * Returns true if the given (original) filepath or unixified path are equal\r\n * to the given pattern.\r\n */\n\n\nutils._equals = function (filepath, unixPath, pattern) {\n  return pattern === filepath || pattern === unixPath;\n};\n/**\r\n * Returns true if the given (original) filepath or unixified path contain\r\n * the given pattern.\r\n */\n\n\nutils._contains = function (filepath, unixPath, pattern) {\n  return filepath.indexOf(pattern) !== -1 || unixPath.indexOf(pattern) !== -1;\n};\n/**\r\n * Returns a function that returns true if the given\r\n * pattern is the same as a given `filepath`\r\n *\r\n * @param {String} `pattern`\r\n * @return {Function}\r\n */\n\n\nutils.equalsPattern = function (pattern, options) {\n  var unixify = utils.unixify(options);\n  options = options || {};\n  return function fn(filepath) {\n    var equal = utils._equals(filepath, unixify(filepath), pattern);\n\n    if (equal === true || options.nocase !== true) {\n      return equal;\n    }\n\n    var lower = filepath.toLowerCase();\n    return utils._equals(lower, unixify(lower), pattern);\n  };\n};\n/**\r\n * Returns a function that returns true if the given\r\n * pattern contains a `filepath`\r\n *\r\n * @param {String} `pattern`\r\n * @return {Function}\r\n */\n\n\nutils.containsPattern = function (pattern, options) {\n  var unixify = utils.unixify(options);\n  options = options || {};\n  return function (filepath) {\n    var contains = utils._contains(filepath, unixify(filepath), pattern);\n\n    if (contains === true || options.nocase !== true) {\n      return contains;\n    }\n\n    var lower = filepath.toLowerCase();\n    return utils._contains(lower, unixify(lower), pattern);\n  };\n};\n/**\r\n * Returns a function that returns true if the given\r\n * regex matches the `filename` of a file path.\r\n *\r\n * @param {RegExp} `re` Matching regex\r\n * @return {Function}\r\n */\n\n\nutils.matchBasename = function (re) {\n  return function (filepath) {\n    return re.test(path.basename(filepath));\n  };\n};\n/**\r\n * Determines the filepath to return based on the provided options.\r\n * @return {any}\r\n */\n\n\nutils.value = function (str, unixify, options) {\n  if (options && options.unixify === false) {\n    return str;\n  }\n\n  return unixify(str);\n};\n/**\r\n * Returns a function that normalizes slashes in a string to forward\r\n * slashes, strips `./` from beginning of paths, and optionally unescapes\r\n * special characters.\r\n * @return {Function}\r\n */\n\n\nutils.unixify = function (options) {\n  options = options || {};\n  return function (filepath) {\n    if (utils.isWindows() || options.unixify === true) {\n      filepath = utils.toPosixPath(filepath);\n    }\n\n    if (options.stripPrefix !== false) {\n      filepath = utils.stripPrefix(filepath);\n    }\n\n    if (options.unescape === true) {\n      filepath = utils.unescape(filepath);\n    }\n\n    return filepath;\n  };\n};","map":{"version":3,"sources":["C:/frontend/node_modules/micromatch/lib/utils.js"],"names":["utils","module","exports","path","require","Snapdragon","define","diff","extend","pick","typeOf","unique","isWindows","sep","process","platform","instantiate","ast","options","snapdragon","str","parsed","prototype","parse","apply","arguments","input","last","parser","stack","pop","strictErrors","open","nodes","inner","type","val","charAt","sibling","parent","loose","createKey","pattern","keys","Object","i","length","key","String","arrayify","Array","isArray","isString","isObject","hasSpecialChars","test","escapeRegex","replace","toPosixPath","unescape","stripPrefix","ch","isSlash","slice","matchPath","contains","containsPattern","equalsPattern","_equals","filepath","unixPath","_contains","indexOf","unixify","fn","equal","nocase","lower","toLowerCase","matchBasename","re","basename","value"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nvar utils = module.exports;\r\nvar path = require('path');\r\n\r\n/**\r\n * Module dependencies\r\n */\r\n\r\nvar Snapdragon = require('snapdragon');\r\nutils.define = require('define-property');\r\nutils.diff = require('arr-diff');\r\nutils.extend = require('extend-shallow');\r\nutils.pick = require('object.pick');\r\nutils.typeOf = require('kind-of');\r\nutils.unique = require('array-unique');\r\n\r\n/**\r\n * Returns true if the platform is windows, or `path.sep` is `\\\\`.\r\n * This is defined as a function to allow `path.sep` to be set in unit tests,\r\n * or by the user, if there is a reason to do so.\r\n * @return {Boolean}\r\n */\r\n\r\nutils.isWindows = function() {\r\n  return path.sep === '\\\\' || process.platform === 'win32';\r\n};\r\n\r\n/**\r\n * Get the `Snapdragon` instance to use\r\n */\r\n\r\nutils.instantiate = function(ast, options) {\r\n  var snapdragon;\r\n  // if an instance was created by `.parse`, use that instance\r\n  if (utils.typeOf(ast) === 'object' && ast.snapdragon) {\r\n    snapdragon = ast.snapdragon;\r\n  // if the user supplies an instance on options, use that instance\r\n  } else if (utils.typeOf(options) === 'object' && options.snapdragon) {\r\n    snapdragon = options.snapdragon;\r\n  // create a new instance\r\n  } else {\r\n    snapdragon = new Snapdragon(options);\r\n  }\r\n\r\n  utils.define(snapdragon, 'parse', function(str, options) {\r\n    var parsed = Snapdragon.prototype.parse.apply(this, arguments);\r\n    parsed.input = str;\r\n\r\n    // escape unmatched brace/bracket/parens\r\n    var last = this.parser.stack.pop();\r\n    if (last && this.options.strictErrors !== true) {\r\n      var open = last.nodes[0];\r\n      var inner = last.nodes[1];\r\n      if (last.type === 'bracket') {\r\n        if (inner.val.charAt(0) === '[') {\r\n          inner.val = '\\\\' + inner.val;\r\n        }\r\n\r\n      } else {\r\n        open.val = '\\\\' + open.val;\r\n        var sibling = open.parent.nodes[1];\r\n        if (sibling.type === 'star') {\r\n          sibling.loose = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    // add non-enumerable parser reference\r\n    utils.define(parsed, 'parser', this.parser);\r\n    return parsed;\r\n  });\r\n\r\n  return snapdragon;\r\n};\r\n\r\n/**\r\n * Create the key to use for memoization. The key is generated\r\n * by iterating over the options and concatenating key-value pairs\r\n * to the pattern string.\r\n */\r\n\r\nutils.createKey = function(pattern, options) {\r\n  if (utils.typeOf(options) !== 'object') {\r\n    return pattern;\r\n  }\r\n  var val = pattern;\r\n  var keys = Object.keys(options);\r\n  for (var i = 0; i < keys.length; i++) {\r\n    var key = keys[i];\r\n    val += ';' + key + '=' + String(options[key]);\r\n  }\r\n  return val;\r\n};\r\n\r\n/**\r\n * Cast `val` to an array\r\n * @return {Array}\r\n */\r\n\r\nutils.arrayify = function(val) {\r\n  if (typeof val === 'string') return [val];\r\n  return val ? (Array.isArray(val) ? val : [val]) : [];\r\n};\r\n\r\n/**\r\n * Return true if `val` is a non-empty string\r\n */\r\n\r\nutils.isString = function(val) {\r\n  return typeof val === 'string';\r\n};\r\n\r\n/**\r\n * Return true if `val` is a non-empty string\r\n */\r\n\r\nutils.isObject = function(val) {\r\n  return utils.typeOf(val) === 'object';\r\n};\r\n\r\n/**\r\n * Returns true if the given `str` has special characters\r\n */\r\n\r\nutils.hasSpecialChars = function(str) {\r\n  return /(?:(?:(^|\\/)[!.])|[*?+()|\\[\\]{}]|[+@]\\()/.test(str);\r\n};\r\n\r\n/**\r\n * Escape regex characters in the given string\r\n */\r\n\r\nutils.escapeRegex = function(str) {\r\n  return str.replace(/[-[\\]{}()^$|*+?.\\\\\\/\\s]/g, '\\\\$&');\r\n};\r\n\r\n/**\r\n * Normalize slashes in the given filepath.\r\n *\r\n * @param {String} `filepath`\r\n * @return {String}\r\n */\r\n\r\nutils.toPosixPath = function(str) {\r\n  return str.replace(/\\\\+/g, '/');\r\n};\r\n\r\n/**\r\n * Strip backslashes before special characters in a string.\r\n *\r\n * @param {String} `str`\r\n * @return {String}\r\n */\r\n\r\nutils.unescape = function(str) {\r\n  return utils.toPosixPath(str.replace(/\\\\(?=[*+?!.])/g, ''));\r\n};\r\n\r\n/**\r\n * Strip the prefix from a filepath\r\n * @param {String} `fp`\r\n * @return {String}\r\n */\r\n\r\nutils.stripPrefix = function(str) {\r\n  if (str.charAt(0) !== '.') {\r\n    return str;\r\n  }\r\n  var ch = str.charAt(1);\r\n  if (utils.isSlash(ch)) {\r\n    return str.slice(2);\r\n  }\r\n  return str;\r\n};\r\n\r\n/**\r\n * Returns true if the given str is an escaped or\r\n * unescaped path character\r\n */\r\n\r\nutils.isSlash = function(str) {\r\n  return str === '/' || str === '\\\\/' || str === '\\\\' || str === '\\\\\\\\';\r\n};\r\n\r\n/**\r\n * Returns a function that returns true if the given\r\n * pattern matches or contains a `filepath`\r\n *\r\n * @param {String} `pattern`\r\n * @return {Function}\r\n */\r\n\r\nutils.matchPath = function(pattern, options) {\r\n  return (options && options.contains)\r\n    ? utils.containsPattern(pattern, options)\r\n    : utils.equalsPattern(pattern, options);\r\n};\r\n\r\n/**\r\n * Returns true if the given (original) filepath or unixified path are equal\r\n * to the given pattern.\r\n */\r\n\r\nutils._equals = function(filepath, unixPath, pattern) {\r\n  return pattern === filepath || pattern === unixPath;\r\n};\r\n\r\n/**\r\n * Returns true if the given (original) filepath or unixified path contain\r\n * the given pattern.\r\n */\r\n\r\nutils._contains = function(filepath, unixPath, pattern) {\r\n  return filepath.indexOf(pattern) !== -1 || unixPath.indexOf(pattern) !== -1;\r\n};\r\n\r\n/**\r\n * Returns a function that returns true if the given\r\n * pattern is the same as a given `filepath`\r\n *\r\n * @param {String} `pattern`\r\n * @return {Function}\r\n */\r\n\r\nutils.equalsPattern = function(pattern, options) {\r\n  var unixify = utils.unixify(options);\r\n  options = options || {};\r\n\r\n  return function fn(filepath) {\r\n    var equal = utils._equals(filepath, unixify(filepath), pattern);\r\n    if (equal === true || options.nocase !== true) {\r\n      return equal;\r\n    }\r\n    var lower = filepath.toLowerCase();\r\n    return utils._equals(lower, unixify(lower), pattern);\r\n  };\r\n};\r\n\r\n/**\r\n * Returns a function that returns true if the given\r\n * pattern contains a `filepath`\r\n *\r\n * @param {String} `pattern`\r\n * @return {Function}\r\n */\r\n\r\nutils.containsPattern = function(pattern, options) {\r\n  var unixify = utils.unixify(options);\r\n  options = options || {};\r\n\r\n  return function(filepath) {\r\n    var contains = utils._contains(filepath, unixify(filepath), pattern);\r\n    if (contains === true || options.nocase !== true) {\r\n      return contains;\r\n    }\r\n    var lower = filepath.toLowerCase();\r\n    return utils._contains(lower, unixify(lower), pattern);\r\n  };\r\n};\r\n\r\n/**\r\n * Returns a function that returns true if the given\r\n * regex matches the `filename` of a file path.\r\n *\r\n * @param {RegExp} `re` Matching regex\r\n * @return {Function}\r\n */\r\n\r\nutils.matchBasename = function(re) {\r\n  return function(filepath) {\r\n    return re.test(path.basename(filepath));\r\n  };\r\n};\r\n\r\n/**\r\n * Determines the filepath to return based on the provided options.\r\n * @return {any}\r\n */\r\n\r\nutils.value = function(str, unixify, options) {\r\n  if (options && options.unixify === false) {\r\n    return str;\r\n  }\r\n  return unixify(str);\r\n};\r\n\r\n/**\r\n * Returns a function that normalizes slashes in a string to forward\r\n * slashes, strips `./` from beginning of paths, and optionally unescapes\r\n * special characters.\r\n * @return {Function}\r\n */\r\n\r\nutils.unixify = function(options) {\r\n  options = options || {};\r\n  return function(filepath) {\r\n    if (utils.isWindows() || options.unixify === true) {\r\n      filepath = utils.toPosixPath(filepath);\r\n    }\r\n    if (options.stripPrefix !== false) {\r\n      filepath = utils.stripPrefix(filepath);\r\n    }\r\n    if (options.unescape === true) {\r\n      filepath = utils.unescape(filepath);\r\n    }\r\n    return filepath;\r\n  };\r\n};\r\n"]},"metadata":{},"sourceType":"script"}