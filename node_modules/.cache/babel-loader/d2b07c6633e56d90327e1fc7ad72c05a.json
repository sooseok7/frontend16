{"ast":null,"code":"'use strict';\n\nvar util = require('util');\n\nvar define = require('define-property');\n\nvar CacheBase = require('cache-base');\n\nvar Emitter = require('component-emitter');\n\nvar isObject = require('isobject');\n\nvar merge = require('mixin-deep');\n\nvar pascal = require('pascalcase');\n\nvar cu = require('class-utils');\n/**\r\n * Optionally define a custom `cache` namespace to use.\r\n */\n\n\nfunction namespace(name) {\n  var Cache = name ? CacheBase.namespace(name) : CacheBase;\n  var fns = [];\n  /**\r\n   * Create an instance of `Base` with the given `config` and `options`.\r\n   *\r\n   * ```js\r\n   * // initialize with `config` and `options`\r\n   * var app = new Base({isApp: true}, {abc: true});\r\n   * app.set('foo', 'bar');\r\n   *\r\n   * // values defined with the given `config` object will be on the root of the instance\r\n   * console.log(app.baz); //=> undefined\r\n   * console.log(app.foo); //=> 'bar'\r\n   * // or use `.get`\r\n   * console.log(app.get('isApp')); //=> true\r\n   * console.log(app.get('foo')); //=> 'bar'\r\n   *\r\n   * // values defined with the given `options` object will be on `app.options\r\n   * console.log(app.options.abc); //=> true\r\n   * ```\r\n   *\r\n   * @param {Object} `config` If supplied, this object is passed to [cache-base][] to merge onto the the instance upon instantiation.\r\n   * @param {Object} `options` If supplied, this object is used to initialize the `base.options` object.\r\n   * @api public\r\n   */\n\n  function Base(config, options) {\n    if (!(this instanceof Base)) {\n      return new Base(config, options);\n    }\n\n    Cache.call(this, config);\n    this.is('base');\n    this.initBase(config, options);\n  }\n  /**\r\n   * Inherit cache-base\r\n   */\n\n\n  util.inherits(Base, Cache);\n  /**\r\n   * Add static emitter methods\r\n   */\n\n  Emitter(Base);\n  /**\r\n   * Initialize `Base` defaults with the given `config` object\r\n   */\n\n  Base.prototype.initBase = function (config, options) {\n    this.options = merge({}, this.options, options);\n    this.cache = this.cache || {};\n    this.define('registered', {});\n    if (name) this[name] = {}; // make `app._callbacks` non-enumerable\n\n    this.define('_callbacks', this._callbacks);\n\n    if (isObject(config)) {\n      this.visit('set', config);\n    }\n\n    Base.run(this, 'use', fns);\n  };\n  /**\r\n   * Set the given `name` on `app._name` and `app.is*` properties. Used for doing\r\n   * lookups in plugins.\r\n   *\r\n   * ```js\r\n   * app.is('foo');\r\n   * console.log(app._name);\r\n   * //=> 'foo'\r\n   * console.log(app.isFoo);\r\n   * //=> true\r\n   * app.is('bar');\r\n   * console.log(app.isFoo);\r\n   * //=> true\r\n   * console.log(app.isBar);\r\n   * //=> true\r\n   * console.log(app._name);\r\n   * //=> 'bar'\r\n   * ```\r\n   * @name .is\r\n   * @param {String} `name`\r\n   * @return {Boolean}\r\n   * @api public\r\n   */\n\n\n  Base.prototype.is = function (name) {\n    if (typeof name !== 'string') {\n      throw new TypeError('expected name to be a string');\n    }\n\n    this.define('is' + pascal(name), true);\n    this.define('_name', name);\n    this.define('_appname', name);\n    return this;\n  };\n  /**\r\n   * Returns true if a plugin has already been registered on an instance.\r\n   *\r\n   * Plugin implementors are encouraged to use this first thing in a plugin\r\n   * to prevent the plugin from being called more than once on the same\r\n   * instance.\r\n   *\r\n   * ```js\r\n   * var base = new Base();\r\n   * base.use(function(app) {\r\n   *   if (app.isRegistered('myPlugin')) return;\r\n   *   // do stuff to `app`\r\n   * });\r\n   *\r\n   * // to also record the plugin as being registered\r\n   * base.use(function(app) {\r\n   *   if (app.isRegistered('myPlugin', true)) return;\r\n   *   // do stuff to `app`\r\n   * });\r\n   * ```\r\n   * @name .isRegistered\r\n   * @emits `plugin` Emits the name of the plugin being registered. Useful for unit tests, to ensure plugins are only registered once.\r\n   * @param {String} `name` The plugin name.\r\n   * @param {Boolean} `register` If the plugin if not already registered, to record it as being registered pass `true` as the second argument.\r\n   * @return {Boolean} Returns true if a plugin is already registered.\r\n   * @api public\r\n   */\n\n\n  Base.prototype.isRegistered = function (name, register) {\n    if (this.registered.hasOwnProperty(name)) {\n      return true;\n    }\n\n    if (register !== false) {\n      this.registered[name] = true;\n      this.emit('plugin', name);\n    }\n\n    return false;\n  };\n  /**\r\n   * Define a plugin function to be called immediately upon init. Plugins are chainable\r\n   * and expose the following arguments to the plugin function:\r\n   *\r\n   * - `app`: the current instance of `Base`\r\n   * - `base`: the [first ancestor instance](#base) of `Base`\r\n   *\r\n   * ```js\r\n   * var app = new Base()\r\n   *   .use(foo)\r\n   *   .use(bar)\r\n   *   .use(baz)\r\n   * ```\r\n   * @name .use\r\n   * @param {Function} `fn` plugin function to call\r\n   * @return {Object} Returns the item instance for chaining.\r\n   * @api public\r\n   */\n\n\n  Base.prototype.use = function (fn) {\n    fn.call(this, this);\n    return this;\n  };\n  /**\r\n   * The `.define` method is used for adding non-enumerable property on the instance.\r\n   * Dot-notation is **not supported** with `define`.\r\n   *\r\n   * ```js\r\n   * // arbitrary `render` function using lodash `template`\r\n   * app.define('render', function(str, locals) {\r\n   *   return _.template(str)(locals);\r\n   * });\r\n   * ```\r\n   * @name .define\r\n   * @param {String} `key` The name of the property to define.\r\n   * @param {any} `value`\r\n   * @return {Object} Returns the instance for chaining.\r\n   * @api public\r\n   */\n\n\n  Base.prototype.define = function (key, val) {\n    if (isObject(key)) {\n      return this.visit('define', key);\n    }\n\n    define(this, key, val);\n    return this;\n  };\n  /**\r\n   * Mix property `key` onto the Base prototype. If base is inherited using\r\n   * `Base.extend` this method will be overridden by a new `mixin` method that will\r\n   * only add properties to the prototype of the inheriting application.\r\n   *\r\n   * ```js\r\n   * app.mixin('foo', function() {\r\n   *   // do stuff\r\n   * });\r\n   * ```\r\n   * @name .mixin\r\n   * @param {String} `key`\r\n   * @param {Object|Array} `val`\r\n   * @return {Object} Returns the `base` instance for chaining.\r\n   * @api public\r\n   */\n\n\n  Base.prototype.mixin = function (key, val) {\n    Base.prototype[key] = val;\n    return this;\n  };\n  /**\r\n   * Non-enumberable mixin array, used by the static [Base.mixin]() method.\r\n   */\n\n\n  Base.prototype.mixins = Base.prototype.mixins || [];\n  /**\r\n   * Getter/setter used when creating nested instances of `Base`, for storing a reference\r\n   * to the first ancestor instance. This works by setting an instance of `Base` on the `parent`\r\n   * property of a \"child\" instance. The `base` property defaults to the current instance if\r\n   * no `parent` property is defined.\r\n   *\r\n   * ```js\r\n   * // create an instance of `Base`, this is our first (\"base\") instance\r\n   * var first = new Base();\r\n   * first.foo = 'bar'; // arbitrary property, to make it easier to see what's happening later\r\n   *\r\n   * // create another instance\r\n   * var second = new Base();\r\n   * // create a reference to the first instance (`first`)\r\n   * second.parent = first;\r\n   *\r\n   * // create another instance\r\n   * var third = new Base();\r\n   * // create a reference to the previous instance (`second`)\r\n   * // repeat this pattern every time a \"child\" instance is created\r\n   * third.parent = second;\r\n   *\r\n   * // we can always access the first instance using the `base` property\r\n   * console.log(first.base.foo);\r\n   * //=> 'bar'\r\n   * console.log(second.base.foo);\r\n   * //=> 'bar'\r\n   * console.log(third.base.foo);\r\n   * //=> 'bar'\r\n   * // and now you know how to get to third base ;)\r\n   * ```\r\n   * @name .base\r\n   * @api public\r\n   */\n\n  Object.defineProperty(Base.prototype, 'base', {\n    configurable: true,\n    get: function () {\n      return this.parent ? this.parent.base : this;\n    }\n  });\n  /**\r\n   * Static method for adding global plugin functions that will\r\n   * be added to an instance when created.\r\n   *\r\n   * ```js\r\n   * Base.use(function(app) {\r\n   *   app.foo = 'bar';\r\n   * });\r\n   * var app = new Base();\r\n   * console.log(app.foo);\r\n   * //=> 'bar'\r\n   * ```\r\n   * @name #use\r\n   * @param {Function} `fn` Plugin function to use on each instance.\r\n   * @return {Object} Returns the `Base` constructor for chaining\r\n   * @api public\r\n   */\n\n  define(Base, 'use', function (fn) {\n    fns.push(fn);\n    return Base;\n  });\n  /**\r\n   * Run an array of functions by passing each function\r\n   * to a method on the given object specified by the given property.\r\n   *\r\n   * @param  {Object} `obj` Object containing method to use.\r\n   * @param  {String} `prop` Name of the method on the object to use.\r\n   * @param  {Array} `arr` Array of functions to pass to the method.\r\n   */\n\n  define(Base, 'run', function (obj, prop, arr) {\n    var len = arr.length,\n        i = 0;\n\n    while (len--) {\n      obj[prop](arr[i++]);\n    }\n\n    return Base;\n  });\n  /**\r\n   * Static method for inheriting the prototype and static methods of the `Base` class.\r\n   * This method greatly simplifies the process of creating inheritance-based applications.\r\n   * See [static-extend][] for more details.\r\n   *\r\n   * ```js\r\n   * var extend = cu.extend(Parent);\r\n   * Parent.extend(Child);\r\n   *\r\n   * // optional methods\r\n   * Parent.extend(Child, {\r\n   *   foo: function() {},\r\n   *   bar: function() {}\r\n   * });\r\n   * ```\r\n   * @name #extend\r\n   * @param {Function} `Ctor` constructor to extend\r\n   * @param {Object} `methods` Optional prototype properties to mix in.\r\n   * @return {Object} Returns the `Base` constructor for chaining\r\n   * @api public\r\n   */\n\n  define(Base, 'extend', cu.extend(Base, function (Ctor, Parent) {\n    Ctor.prototype.mixins = Ctor.prototype.mixins || [];\n    define(Ctor, 'mixin', function (fn) {\n      var mixin = fn(Ctor.prototype, Ctor);\n\n      if (typeof mixin === 'function') {\n        Ctor.prototype.mixins.push(mixin);\n      }\n\n      return Ctor;\n    });\n    define(Ctor, 'mixins', function (Child) {\n      Base.run(Child, 'mixin', Ctor.prototype.mixins);\n      return Ctor;\n    });\n\n    Ctor.prototype.mixin = function (key, value) {\n      Ctor.prototype[key] = value;\n      return this;\n    };\n\n    return Base;\n  }));\n  /**\r\n   * Used for adding methods to the `Base` prototype, and/or to the prototype of child instances.\r\n   * When a mixin function returns a function, the returned function is pushed onto the `.mixins`\r\n   * array, making it available to be used on inheriting classes whenever `Base.mixins()` is\r\n   * called (e.g. `Base.mixins(Child)`).\r\n   *\r\n   * ```js\r\n   * Base.mixin(function(proto) {\r\n   *   proto.foo = function(msg) {\r\n   *     return 'foo ' + msg;\r\n   *   };\r\n   * });\r\n   * ```\r\n   * @name #mixin\r\n   * @param {Function} `fn` Function to call\r\n   * @return {Object} Returns the `Base` constructor for chaining\r\n   * @api public\r\n   */\n\n  define(Base, 'mixin', function (fn) {\n    var mixin = fn(Base.prototype, Base);\n\n    if (typeof mixin === 'function') {\n      Base.prototype.mixins.push(mixin);\n    }\n\n    return Base;\n  });\n  /**\r\n   * Static method for running global mixin functions against a child constructor.\r\n   * Mixins must be registered before calling this method.\r\n   *\r\n   * ```js\r\n   * Base.extend(Child);\r\n   * Base.mixins(Child);\r\n   * ```\r\n   * @name #mixins\r\n   * @param {Function} `Child` Constructor function of a child class\r\n   * @return {Object} Returns the `Base` constructor for chaining\r\n   * @api public\r\n   */\n\n  define(Base, 'mixins', function (Child) {\n    Base.run(Child, 'mixin', Base.prototype.mixins);\n    return Base;\n  });\n  /**\r\n   * Similar to `util.inherit`, but copies all static properties, prototype properties, and\r\n   * getters/setters from `Provider` to `Receiver`. See [class-utils][]{#inherit} for more details.\r\n   *\r\n   * ```js\r\n   * Base.inherit(Foo, Bar);\r\n   * ```\r\n   * @name #inherit\r\n   * @param {Function} `Receiver` Receiving (child) constructor\r\n   * @param {Function} `Provider` Providing (parent) constructor\r\n   * @return {Object} Returns the `Base` constructor for chaining\r\n   * @api public\r\n   */\n\n  define(Base, 'inherit', cu.inherit);\n  define(Base, 'bubble', cu.bubble);\n  return Base;\n}\n/**\r\n * Expose `Base` with default settings\r\n */\n\n\nmodule.exports = namespace();\n/**\r\n * Allow users to define a namespace\r\n */\n\nmodule.exports.namespace = namespace;","map":{"version":3,"sources":["C:/frontend/node_modules/base/index.js"],"names":["util","require","define","CacheBase","Emitter","isObject","merge","pascal","cu","namespace","name","Cache","fns","Base","config","options","call","is","initBase","inherits","prototype","cache","_callbacks","visit","run","TypeError","isRegistered","register","registered","hasOwnProperty","emit","use","fn","key","val","mixin","mixins","Object","defineProperty","configurable","get","parent","base","push","obj","prop","arr","len","length","i","extend","Ctor","Parent","Child","value","inherit","bubble","module","exports"],"mappings":"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F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEEG,EAAAA,IAAI,CAACO,SAAL,CAAeW,GAAf,GAAqB,UAASC,EAAT,EAAa;AAChCA,IAAAA,EAAE,CAAChB,IAAH,CAAQ,IAAR,EAAc,IAAd;AACA,WAAO,IAAP;AACD,GAHD;AAKA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEEH,EAAAA,IAAI,CAACO,SAAL,CAAelB,MAAf,GAAwB,UAAS+B,GAAT,EAAcC,GAAd,EAAmB;AACzC,QAAI7B,QAAQ,CAAC4B,GAAD,CAAZ,EAAmB;AACjB,aAAO,KAAKV,KAAL,CAAW,QAAX,EAAqBU,GAArB,CAAP;AACD;;AACD/B,IAAAA,MAAM,CAAC,IAAD,EAAO+B,GAAP,EAAYC,GAAZ,CAAN;AACA,WAAO,IAAP;AACD,GAND;AAQA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEErB,EAAAA,IAAI,CAACO,SAAL,CAAee,KAAf,GAAuB,UAASF,GAAT,EAAcC,GAAd,EAAmB;AACxCrB,IAAAA,IAAI,CAACO,SAAL,CAAea,GAAf,IAAsBC,GAAtB;AACA,WAAO,IAAP;AACD,GAHD;AAKA;AACF;AACA;;;AAEErB,EAAAA,IAAI,CAACO,SAAL,CAAegB,MAAf,GAAwBvB,IAAI,CAACO,SAAL,CAAegB,MAAf,IAAyB,EAAjD;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEEC,EAAAA,MAAM,CAACC,cAAP,CAAsBzB,IAAI,CAACO,SAA3B,EAAsC,MAAtC,EAA8C;AAC5CmB,IAAAA,YAAY,EAAE,IAD8B;AAE5CC,IAAAA,GAAG,EAAE,YAAW;AACd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","sourcesContent":["'use strict';\r\n\r\nvar util = require('util');\r\nvar define = require('define-property');\r\nvar CacheBase = require('cache-base');\r\nvar Emitter = require('component-emitter');\r\nvar isObject = require('isobject');\r\nvar merge = require('mixin-deep');\r\nvar pascal = require('pascalcase');\r\nvar cu = require('class-utils');\r\n\r\n/**\r\n * Optionally define a custom `cache` namespace to use.\r\n */\r\n\r\nfunction namespace(name) {\r\n  var Cache = name ? CacheBase.namespace(name) : CacheBase;\r\n  var fns = [];\r\n\r\n  /**\r\n   * Create an instance of `Base` with the given `config` and `options`.\r\n   *\r\n   * ```js\r\n   * // initialize with `config` and `options`\r\n   * var app = new Base({isApp: true}, {abc: true});\r\n   * app.set('foo', 'bar');\r\n   *\r\n   * // values defined with the given `config` object will be on the root of the instance\r\n   * console.log(app.baz); //=> undefined\r\n   * console.log(app.foo); //=> 'bar'\r\n   * // or use `.get`\r\n   * console.log(app.get('isApp')); //=> true\r\n   * console.log(app.get('foo')); //=> 'bar'\r\n   *\r\n   * // values defined with the given `options` object will be on `app.options\r\n   * console.log(app.options.abc); //=> true\r\n   * ```\r\n   *\r\n   * @param {Object} `config` If supplied, this object is passed to [cache-base][] to merge onto the the instance upon instantiation.\r\n   * @param {Object} `options` If supplied, this object is used to initialize the `base.options` object.\r\n   * @api public\r\n   */\r\n\r\n  function Base(config, options) {\r\n    if (!(this instanceof Base)) {\r\n      return new Base(config, options);\r\n    }\r\n    Cache.call(this, config);\r\n    this.is('base');\r\n    this.initBase(config, options);\r\n  }\r\n\r\n  /**\r\n   * Inherit cache-base\r\n   */\r\n\r\n  util.inherits(Base, Cache);\r\n\r\n  /**\r\n   * Add static emitter methods\r\n   */\r\n\r\n  Emitter(Base);\r\n\r\n  /**\r\n   * Initialize `Base` defaults with the given `config` object\r\n   */\r\n\r\n  Base.prototype.initBase = function(config, options) {\r\n    this.options = merge({}, this.options, options);\r\n    this.cache = this.cache || {};\r\n    this.define('registered', {});\r\n    if (name) this[name] = {};\r\n\r\n    // make `app._callbacks` non-enumerable\r\n    this.define('_callbacks', this._callbacks);\r\n    if (isObject(config)) {\r\n      this.visit('set', config);\r\n    }\r\n    Base.run(this, 'use', fns);\r\n  };\r\n\r\n  /**\r\n   * Set the given `name` on `app._name` and `app.is*` properties. Used for doing\r\n   * lookups in plugins.\r\n   *\r\n   * ```js\r\n   * app.is('foo');\r\n   * console.log(app._name);\r\n   * //=> 'foo'\r\n   * console.log(app.isFoo);\r\n   * //=> true\r\n   * app.is('bar');\r\n   * console.log(app.isFoo);\r\n   * //=> true\r\n   * console.log(app.isBar);\r\n   * //=> true\r\n   * console.log(app._name);\r\n   * //=> 'bar'\r\n   * ```\r\n   * @name .is\r\n   * @param {String} `name`\r\n   * @return {Boolean}\r\n   * @api public\r\n   */\r\n\r\n  Base.prototype.is = function(name) {\r\n    if (typeof name !== 'string') {\r\n      throw new TypeError('expected name to be a string');\r\n    }\r\n    this.define('is' + pascal(name), true);\r\n    this.define('_name', name);\r\n    this.define('_appname', name);\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Returns true if a plugin has already been registered on an instance.\r\n   *\r\n   * Plugin implementors are encouraged to use this first thing in a plugin\r\n   * to prevent the plugin from being called more than once on the same\r\n   * instance.\r\n   *\r\n   * ```js\r\n   * var base = new Base();\r\n   * base.use(function(app) {\r\n   *   if (app.isRegistered('myPlugin')) return;\r\n   *   // do stuff to `app`\r\n   * });\r\n   *\r\n   * // to also record the plugin as being registered\r\n   * base.use(function(app) {\r\n   *   if (app.isRegistered('myPlugin', true)) return;\r\n   *   // do stuff to `app`\r\n   * });\r\n   * ```\r\n   * @name .isRegistered\r\n   * @emits `plugin` Emits the name of the plugin being registered. Useful for unit tests, to ensure plugins are only registered once.\r\n   * @param {String} `name` The plugin name.\r\n   * @param {Boolean} `register` If the plugin if not already registered, to record it as being registered pass `true` as the second argument.\r\n   * @return {Boolean} Returns true if a plugin is already registered.\r\n   * @api public\r\n   */\r\n\r\n  Base.prototype.isRegistered = function(name, register) {\r\n    if (this.registered.hasOwnProperty(name)) {\r\n      return true;\r\n    }\r\n    if (register !== false) {\r\n      this.registered[name] = true;\r\n      this.emit('plugin', name);\r\n    }\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Define a plugin function to be called immediately upon init. Plugins are chainable\r\n   * and expose the following arguments to the plugin function:\r\n   *\r\n   * - `app`: the current instance of `Base`\r\n   * - `base`: the [first ancestor instance](#base) of `Base`\r\n   *\r\n   * ```js\r\n   * var app = new Base()\r\n   *   .use(foo)\r\n   *   .use(bar)\r\n   *   .use(baz)\r\n   * ```\r\n   * @name .use\r\n   * @param {Function} `fn` plugin function to call\r\n   * @return {Object} Returns the item instance for chaining.\r\n   * @api public\r\n   */\r\n\r\n  Base.prototype.use = function(fn) {\r\n    fn.call(this, this);\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * The `.define` method is used for adding non-enumerable property on the instance.\r\n   * Dot-notation is **not supported** with `define`.\r\n   *\r\n   * ```js\r\n   * // arbitrary `render` function using lodash `template`\r\n   * app.define('render', function(str, locals) {\r\n   *   return _.template(str)(locals);\r\n   * });\r\n   * ```\r\n   * @name .define\r\n   * @param {String} `key` The name of the property to define.\r\n   * @param {any} `value`\r\n   * @return {Object} Returns the instance for chaining.\r\n   * @api public\r\n   */\r\n\r\n  Base.prototype.define = function(key, val) {\r\n    if (isObject(key)) {\r\n      return this.visit('define', key);\r\n    }\r\n    define(this, key, val);\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Mix property `key` onto the Base prototype. If base is inherited using\r\n   * `Base.extend` this method will be overridden by a new `mixin` method that will\r\n   * only add properties to the prototype of the inheriting application.\r\n   *\r\n   * ```js\r\n   * app.mixin('foo', function() {\r\n   *   // do stuff\r\n   * });\r\n   * ```\r\n   * @name .mixin\r\n   * @param {String} `key`\r\n   * @param {Object|Array} `val`\r\n   * @return {Object} Returns the `base` instance for chaining.\r\n   * @api public\r\n   */\r\n\r\n  Base.prototype.mixin = function(key, val) {\r\n    Base.prototype[key] = val;\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Non-enumberable mixin array, used by the static [Base.mixin]() method.\r\n   */\r\n\r\n  Base.prototype.mixins = Base.prototype.mixins || [];\r\n\r\n  /**\r\n   * Getter/setter used when creating nested instances of `Base`, for storing a reference\r\n   * to the first ancestor instance. This works by setting an instance of `Base` on the `parent`\r\n   * property of a \"child\" instance. The `base` property defaults to the current instance if\r\n   * no `parent` property is defined.\r\n   *\r\n   * ```js\r\n   * // create an instance of `Base`, this is our first (\"base\") instance\r\n   * var first = new Base();\r\n   * first.foo = 'bar'; // arbitrary property, to make it easier to see what's happening later\r\n   *\r\n   * // create another instance\r\n   * var second = new Base();\r\n   * // create a reference to the first instance (`first`)\r\n   * second.parent = first;\r\n   *\r\n   * // create another instance\r\n   * var third = new Base();\r\n   * // create a reference to the previous instance (`second`)\r\n   * // repeat this pattern every time a \"child\" instance is created\r\n   * third.parent = second;\r\n   *\r\n   * // we can always access the first instance using the `base` property\r\n   * console.log(first.base.foo);\r\n   * //=> 'bar'\r\n   * console.log(second.base.foo);\r\n   * //=> 'bar'\r\n   * console.log(third.base.foo);\r\n   * //=> 'bar'\r\n   * // and now you know how to get to third base ;)\r\n   * ```\r\n   * @name .base\r\n   * @api public\r\n   */\r\n\r\n  Object.defineProperty(Base.prototype, 'base', {\r\n    configurable: true,\r\n    get: function() {\r\n      return this.parent ? this.parent.base : this;\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Static method for adding global plugin functions that will\r\n   * be added to an instance when created.\r\n   *\r\n   * ```js\r\n   * Base.use(function(app) {\r\n   *   app.foo = 'bar';\r\n   * });\r\n   * var app = new Base();\r\n   * console.log(app.foo);\r\n   * //=> 'bar'\r\n   * ```\r\n   * @name #use\r\n   * @param {Function} `fn` Plugin function to use on each instance.\r\n   * @return {Object} Returns the `Base` constructor for chaining\r\n   * @api public\r\n   */\r\n\r\n  define(Base, 'use', function(fn) {\r\n    fns.push(fn);\r\n    return Base;\r\n  });\r\n\r\n  /**\r\n   * Run an array of functions by passing each function\r\n   * to a method on the given object specified by the given property.\r\n   *\r\n   * @param  {Object} `obj` Object containing method to use.\r\n   * @param  {String} `prop` Name of the method on the object to use.\r\n   * @param  {Array} `arr` Array of functions to pass to the method.\r\n   */\r\n\r\n  define(Base, 'run', function(obj, prop, arr) {\r\n    var len = arr.length, i = 0;\r\n    while (len--) {\r\n      obj[prop](arr[i++]);\r\n    }\r\n    return Base;\r\n  });\r\n\r\n  /**\r\n   * Static method for inheriting the prototype and static methods of the `Base` class.\r\n   * This method greatly simplifies the process of creating inheritance-based applications.\r\n   * See [static-extend][] for more details.\r\n   *\r\n   * ```js\r\n   * var extend = cu.extend(Parent);\r\n   * Parent.extend(Child);\r\n   *\r\n   * // optional methods\r\n   * Parent.extend(Child, {\r\n   *   foo: function() {},\r\n   *   bar: function() {}\r\n   * });\r\n   * ```\r\n   * @name #extend\r\n   * @param {Function} `Ctor` constructor to extend\r\n   * @param {Object} `methods` Optional prototype properties to mix in.\r\n   * @return {Object} Returns the `Base` constructor for chaining\r\n   * @api public\r\n   */\r\n\r\n  define(Base, 'extend', cu.extend(Base, function(Ctor, Parent) {\r\n    Ctor.prototype.mixins = Ctor.prototype.mixins || [];\r\n\r\n    define(Ctor, 'mixin', function(fn) {\r\n      var mixin = fn(Ctor.prototype, Ctor);\r\n      if (typeof mixin === 'function') {\r\n        Ctor.prototype.mixins.push(mixin);\r\n      }\r\n      return Ctor;\r\n    });\r\n\r\n    define(Ctor, 'mixins', function(Child) {\r\n      Base.run(Child, 'mixin', Ctor.prototype.mixins);\r\n      return Ctor;\r\n    });\r\n\r\n    Ctor.prototype.mixin = function(key, value) {\r\n      Ctor.prototype[key] = value;\r\n      return this;\r\n    };\r\n    return Base;\r\n  }));\r\n\r\n  /**\r\n   * Used for adding methods to the `Base` prototype, and/or to the prototype of child instances.\r\n   * When a mixin function returns a function, the returned function is pushed onto the `.mixins`\r\n   * array, making it available to be used on inheriting classes whenever `Base.mixins()` is\r\n   * called (e.g. `Base.mixins(Child)`).\r\n   *\r\n   * ```js\r\n   * Base.mixin(function(proto) {\r\n   *   proto.foo = function(msg) {\r\n   *     return 'foo ' + msg;\r\n   *   };\r\n   * });\r\n   * ```\r\n   * @name #mixin\r\n   * @param {Function} `fn` Function to call\r\n   * @return {Object} Returns the `Base` constructor for chaining\r\n   * @api public\r\n   */\r\n\r\n  define(Base, 'mixin', function(fn) {\r\n    var mixin = fn(Base.prototype, Base);\r\n    if (typeof mixin === 'function') {\r\n      Base.prototype.mixins.push(mixin);\r\n    }\r\n    return Base;\r\n  });\r\n\r\n  /**\r\n   * Static method for running global mixin functions against a child constructor.\r\n   * Mixins must be registered before calling this method.\r\n   *\r\n   * ```js\r\n   * Base.extend(Child);\r\n   * Base.mixins(Child);\r\n   * ```\r\n   * @name #mixins\r\n   * @param {Function} `Child` Constructor function of a child class\r\n   * @return {Object} Returns the `Base` constructor for chaining\r\n   * @api public\r\n   */\r\n\r\n  define(Base, 'mixins', function(Child) {\r\n    Base.run(Child, 'mixin', Base.prototype.mixins);\r\n    return Base;\r\n  });\r\n\r\n  /**\r\n   * Similar to `util.inherit`, but copies all static properties, prototype properties, and\r\n   * getters/setters from `Provider` to `Receiver`. See [class-utils][]{#inherit} for more details.\r\n   *\r\n   * ```js\r\n   * Base.inherit(Foo, Bar);\r\n   * ```\r\n   * @name #inherit\r\n   * @param {Function} `Receiver` Receiving (child) constructor\r\n   * @param {Function} `Provider` Providing (parent) constructor\r\n   * @return {Object} Returns the `Base` constructor for chaining\r\n   * @api public\r\n   */\r\n\r\n  define(Base, 'inherit', cu.inherit);\r\n  define(Base, 'bubble', cu.bubble);\r\n  return Base;\r\n}\r\n\r\n/**\r\n * Expose `Base` with default settings\r\n */\r\n\r\nmodule.exports = namespace();\r\n\r\n/**\r\n * Allow users to define a namespace\r\n */\r\n\r\nmodule.exports.namespace = namespace;\r\n"]},"metadata":{},"sourceType":"script"}