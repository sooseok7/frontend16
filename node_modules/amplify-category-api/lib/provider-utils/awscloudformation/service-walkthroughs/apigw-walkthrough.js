"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.openConsole = exports.getIAMPolicies = exports.migrate = exports.updateWalkthrough = exports.serviceWalkthrough = void 0;
const amplify_cli_core_1 = require("amplify-cli-core");
const fs = __importStar(require("fs-extra"));
const inquirer_1 = __importDefault(require("inquirer"));
const os_1 = __importDefault(require("os"));
const path = __importStar(require("path"));
const uuid_1 = __importDefault(require("uuid"));
const aws_constants_1 = require("../aws-constants");
const rest_api_path_utils_1 = require("../utils/rest-api-path-utils");
const FunctionServiceNameLambdaFunction = 'Lambda';
const category = 'api';
const serviceName = 'API Gateway';
const elasticContainerServiceName = 'ElasticContainer';
const parametersFileName = 'api-params.json';
const cfnParametersFilename = 'parameters.json';
async function serviceWalkthrough(context, defaultValuesFilename) {
    const { amplify } = context;
    const defaultValuesSrc = `${__dirname}/../default-values/${defaultValuesFilename}`;
    const { getAllDefaults } = await Promise.resolve().then(() => __importStar(require(defaultValuesSrc)));
    const allDefaultValues = getAllDefaults(amplify.getProjectDetails());
    let answers = {
        paths: [],
    };
    const apiNames = await askApiNames(context, allDefaultValues);
    answers = { ...answers, ...apiNames };
    return pathFlow(context, answers);
}
exports.serviceWalkthrough = serviceWalkthrough;
async function updateWalkthrough(context, defaultValuesFilename) {
    const { amplify } = context;
    const { allResources } = await context.amplify.getResourceStatus();
    const defaultValuesSrc = `${__dirname}/../default-values/${defaultValuesFilename}`;
    const { getAllDefaults } = await Promise.resolve().then(() => __importStar(require(defaultValuesSrc)));
    const allDefaultValues = getAllDefaults(amplify.getProjectDetails());
    const resources = allResources
        .filter(resource => resource.service === serviceName && resource.mobileHubMigrated !== true)
        .map(resource => resource.resourceName);
    if (resources.length === 0) {
        const errMessage = 'No REST API resource to update. Please use "amplify add api" command to create a new REST API';
        context.print.error(errMessage);
        await context.usageData.emitError(new amplify_cli_core_1.ResourceDoesNotExistError(errMessage));
        amplify_cli_core_1.exitOnNextTick(0);
        return;
    }
    let answers = {
        paths: [],
    };
    const question = [
        {
            name: 'resourceName',
            message: 'Please select the REST API you would want to update',
            type: 'list',
            choices: resources,
        },
        {
            name: 'operation',
            message: 'What would you like to do',
            type: 'list',
            when: context.input.command !== 'add',
            choices: [
                { name: 'Add another path', value: 'add' },
                { name: 'Update path', value: 'update' },
                { name: 'Remove path', value: 'remove' },
            ],
        },
    ];
    const updateApi = await inquirer_1.default.prompt(question);
    if (context.input.command === 'add') {
        updateApi.operation = 'add';
    }
    if (updateApi.resourceName === 'AdminQueries') {
        const errMessage = `The Admin Queries API is maintained through the Auth category and should be updated using 'amplify update auth' command`;
        context.print.warning(errMessage);
        await context.usageData.emitError(new amplify_cli_core_1.ResourceDoesNotExistError(errMessage));
        amplify_cli_core_1.exitOnNextTick(0);
    }
    const projectBackendDirPath = context.amplify.pathManager.getBackendDirPath();
    const resourceDirPath = path.join(projectBackendDirPath, category, updateApi.resourceName);
    const parametersFilePath = path.join(resourceDirPath, parametersFileName);
    let parameters;
    try {
        parameters = context.amplify.readJsonFile(parametersFilePath);
    }
    catch (e) {
        parameters = {};
    }
    parameters.resourceName = updateApi.resourceName;
    Object.assign(allDefaultValues, parameters);
    answers = { ...answers, ...parameters };
    [answers.uuid] = uuid_1.default().split('-');
    const pathList = answers.paths.map(path => path.name);
    let updatedResult = {};
    switch (updateApi.operation) {
        case 'add': {
            updatedResult = pathFlow(context, answers);
            break;
        }
        case 'remove': {
            const pathToRemove = await inquirer_1.default.prompt({
                name: 'path',
                message: 'Please select the path you would want to remove',
                type: 'list',
                choices: pathList,
            });
            answers.paths = answers.paths.filter(path => path.name !== pathToRemove.path);
            const { dependsOn, functionArns } = await findDependsOn(answers.paths, context);
            answers.dependsOn = dependsOn;
            answers.functionArns = functionArns;
            updatedResult = { answers, dependsOn };
            break;
        }
        case 'update': {
            const pathToEdit = await inquirer_1.default.prompt({
                name: 'path',
                message: 'Please select the path you would want to edit',
                type: 'list',
                choices: pathList,
            });
            const currentPath = answers.paths.find(path => path.name === pathToEdit.path);
            answers.paths = answers.paths.filter(path => path.name !== pathToEdit.path);
            updatedResult = pathFlow(context, answers, currentPath);
            break;
        }
        default: {
            updatedResult = {};
        }
    }
    return updatedResult;
}
exports.updateWalkthrough = updateWalkthrough;
async function pathFlow(context, answers, currentPath) {
    const pathsAnswer = await askPaths(context, answers, currentPath);
    answers = { ...answers, paths: pathsAnswer.paths, functionArns: pathsAnswer.functionArns };
    const { dependsOn } = pathsAnswer;
    const privacy = {
        auth: pathsAnswer.paths.filter(path => path.privacy.auth && path.privacy.auth.length > 0).length,
        unauth: pathsAnswer.paths.filter(path => path.privacy.unauth && path.privacy.unauth.length > 0).length,
    };
    answers = { ...answers, privacy, dependsOn };
    if (context.amplify.getProjectDetails() &&
        context.amplify.getProjectDetails().amplifyMeta &&
        context.amplify.getProjectDetails().amplifyMeta.providers &&
        context.amplify.getProjectDetails().amplifyMeta.providers.awscloudformation) {
        const { amplifyMeta } = context.amplify.getProjectDetails();
        const providerInfo = amplifyMeta.providers.awscloudformation;
        answers.privacy.authRoleName = providerInfo.AuthRoleName;
        answers.privacy.unAuthRoleName = providerInfo.UnauthRoleName;
    }
    return { answers, dependsOn };
}
async function askApiNames(context, defaults) {
    const { amplify } = context;
    const apiNameValidator = (input) => {
        const amplifyValidatorOutput = amplify.inputValidation({
            validation: {
                operator: 'regex',
                value: '^[a-zA-Z0-9]+$',
                onErrorMsg: 'Resource name should be alphanumeric',
            },
            required: true,
        })(input);
        let uniqueCheck = false;
        try {
            uniqueCheck = amplify_cli_core_1.isResourceNameUnique(category, input);
        }
        catch (e) {
            return e.message || e;
        }
        return typeof amplifyValidatorOutput === 'string' ? amplifyValidatorOutput : uniqueCheck;
    };
    const answer = await inquirer_1.default.prompt([
        {
            name: 'resourceName',
            type: 'input',
            message: 'Provide a friendly name for your resource to be used as a label for this category in the project:',
            default: defaults.resourceName,
            validate: apiNameValidator,
        },
    ]);
    answer.apiName = answer.resourceName;
    return answer;
}
async function askPrivacy(context, answers, currentPath) {
    while (true) {
        const apiAccess = await inquirer_1.default.prompt({
            name: 'restrict',
            type: 'confirm',
            default: !(currentPath && currentPath.open),
            message: 'Restrict API access',
        });
        if (!apiAccess.restrict) {
            return { open: true };
        }
        const userPoolGroupList = await context.amplify.getUserPoolGroupList(context);
        let permissionSelected = 'Auth/Guest Users';
        const privacy = {};
        if (userPoolGroupList.length > 0) {
            do {
                if (permissionSelected === 'Learn more') {
                    context.print.info('');
                    context.print.info('You can restrict access using CRUD policies for Authenticated Users, Guest Users, or on individual Group that users belong to in a User Pool. If a user logs into your application and is not a member of any group they will use policy set for “Authenticated Users”, however if they belong to a group they will only get the policy associated with that specific group.');
                    context.print.info('');
                }
                const permissionSelection = await inquirer_1.default.prompt({
                    name: 'selection',
                    type: 'list',
                    message: 'Restrict access by?',
                    choices: ['Auth/Guest Users', 'Individual Groups', 'Both', 'Learn more'],
                    default: 'Auth/Guest Users',
                });
                permissionSelected = permissionSelection.selection;
            } while (permissionSelected === 'Learn more');
        }
        if (permissionSelected === 'Both' || permissionSelected === 'Auth/Guest Users') {
            const answer = await inquirer_1.default.prompt({
                name: 'privacy',
                type: 'list',
                message: 'Who should have access?',
                choices: [
                    {
                        name: 'Authenticated users only',
                        value: 'private',
                    },
                    {
                        name: 'Authenticated and Guest users',
                        value: 'protected',
                    },
                ],
                default: currentPath && currentPath.privacy && currentPath.privacy.protected ? 'protected' : 'private',
            });
            privacy[answer.privacy] = true;
            context.api = {
                privacy: answer.privacy,
            };
            let { privacy: { auth: authPrivacy }, } = currentPath || { privacy: {} };
            let { privacy: { unauth: unauthPrivacy }, } = currentPath || { privacy: {} };
            if (authPrivacy && ['r', 'rw'].includes(authPrivacy)) {
                authPrivacy = convertToCRUD(authPrivacy);
            }
            if (unauthPrivacy && ['r', 'rw'].includes(unauthPrivacy)) {
                unauthPrivacy = convertToCRUD(unauthPrivacy);
            }
            if (answer.privacy === 'private') {
                privacy.auth = await askReadWrite('Authenticated', context, authPrivacy);
                const apiRequirements = { authSelections: 'identityPoolAndUserPool' };
                await ensureAuth(context, apiRequirements, answers.resourceName);
            }
            if (answer.privacy === 'protected') {
                privacy.auth = await askReadWrite('Authenticated', context, authPrivacy);
                privacy.unauth = await askReadWrite('Guest', context, unauthPrivacy);
                const apiRequirements = { authSelections: 'identityPoolAndUserPool', allowUnauthenticatedIdentities: true };
                await ensureAuth(context, apiRequirements, answers.resourceName);
            }
        }
        if (permissionSelected === 'Both' || permissionSelected === 'Individual Groups') {
            const apiRequirements = { authSelections: 'identityPoolAndUserPool' };
            await ensureAuth(context, apiRequirements, answers.resourceName);
            const authResourceName = await getAuthResourceName(context);
            answers.authResourceName = authResourceName;
            let defaultSelectedGroups = [];
            if (currentPath && currentPath.privacy && currentPath.privacy.userPoolGroups) {
                defaultSelectedGroups = Object.keys(currentPath.privacy.userPoolGroups);
            }
            const userPoolGroupSelection = await inquirer_1.default.prompt([
                {
                    name: 'userpoolGroups',
                    type: 'checkbox',
                    message: 'Select groups:',
                    choices: userPoolGroupList,
                    default: defaultSelectedGroups,
                    validate: inputs => {
                        if (inputs.length === 0) {
                            return 'Select at least one option';
                        }
                        return true;
                    },
                },
            ]);
            const selectedUserPoolGroupList = userPoolGroupSelection.userpoolGroups;
            for (let i = 0; i < selectedUserPoolGroupList.length; i += 1) {
                let defaults = [];
                if (currentPath &&
                    currentPath.privacy &&
                    currentPath.privacy.userPoolGroups &&
                    currentPath.privacy.userPoolGroups[selectedUserPoolGroupList[i]]) {
                    defaults = currentPath.privacy.userPoolGroups[selectedUserPoolGroupList[i]];
                }
                if (!privacy.userPoolGroups) {
                    privacy.userPoolGroups = {};
                }
                privacy.userPoolGroups[selectedUserPoolGroupList[i]] = await askReadWrite(selectedUserPoolGroupList[i], context, defaults);
            }
        }
        return privacy;
    }
}
async function ensureAuth(context, apiRequirements, resourceName) {
    const checkResult = await context.amplify.invokePluginMethod(context, 'auth', undefined, 'checkRequirements', [
        apiRequirements,
        context,
        'api',
        resourceName,
    ]);
    if (checkResult.authImported === true && checkResult.errors && checkResult.errors.length > 0) {
        throw new Error(checkResult.errors.join(os_1.default.EOL));
    }
    if (checkResult.errors && checkResult.errors.length > 0) {
        context.print.warning(checkResult.errors.join(os_1.default.EOL));
    }
    if (!checkResult.authEnabled || !checkResult.requirementsMet) {
        try {
            await context.amplify.invokePluginMethod(context, 'auth', undefined, 'externalAuthEnable', [
                context,
                'api',
                resourceName,
                apiRequirements,
            ]);
        }
        catch (error) {
            context.print.error(error);
            throw error;
        }
    }
}
async function askReadWrite(userType, context, privacy) {
    const permissionMap = {
        create: ['/POST'],
        read: ['/GET'],
        update: ['/PUT', '/PATCH'],
        delete: ['/DELETE'],
    };
    const defaults = [];
    if (privacy) {
        Object.values(permissionMap).forEach((el, index) => {
            if (el.every(i => privacy.includes(i))) {
                defaults.push(Object.keys(permissionMap)[index]);
            }
        });
    }
    const crudAnswers = await context.amplify.crudFlow(userType, permissionMap, defaults);
    return crudAnswers;
}
async function askPaths(context, answers, currentPath) {
    const existingFunctions = functionsExist(context);
    const choices = [
        {
            name: 'Create a new Lambda function',
            value: 'newFunction',
        },
    ];
    if (existingFunctions) {
        choices.push({
            name: 'Use a Lambda function already added in the current Amplify project',
            value: 'projectFunction',
        });
    }
    let defaultFunctionType = 'newFunction';
    if (currentPath) {
        defaultFunctionType = currentPath.lambdaArn ? 'arn' : 'projectFunction';
    }
    const paths = [...answers.paths];
    let addAnotherPath;
    do {
        let pathName;
        let isPathValid;
        do {
            const pathAnswer = await inquirer_1.default.prompt({
                name: 'name',
                type: 'input',
                message: 'Provide a path (e.g., /book/{isbn}):',
                default: currentPath ? currentPath.name : '/items',
                validate: value => rest_api_path_utils_1.validatePathName(value),
            });
            pathName = pathAnswer.name;
            const overlapCheckResult = rest_api_path_utils_1.checkForPathOverlap(pathName, paths);
            if (overlapCheckResult === false) {
                isPathValid = true;
            }
            else {
                const higherOrderPath = overlapCheckResult.higherOrderPath;
                const lowerOrderPath = overlapCheckResult.lowerOrderPath;
                isPathValid = (await inquirer_1.default.prompt({
                    name: 'isOverlappingPathOK',
                    type: 'confirm',
                    message: `The path ${lowerOrderPath} overlaps with ${higherOrderPath}. Users authorized to access ${higherOrderPath} will also have access to ${lowerOrderPath}. Are you sure you want to continue?`,
                    default: false,
                })).isOverlappingPathOK;
            }
        } while (!isPathValid);
        const lambdaAnswer = await inquirer_1.default.prompt({
            name: 'functionType',
            type: 'list',
            message: 'Choose a Lambda source',
            choices,
            default: defaultFunctionType,
        });
        let path = { name: pathName };
        let lambda;
        do {
            lambda = await askLambdaSource(context, lambdaAnswer.functionType, path.name, currentPath);
        } while (!lambda);
        const privacy = await askPrivacy(context, answers, currentPath);
        path = { ...path, ...lambda, privacy };
        paths.push(path);
        if (currentPath) {
            break;
        }
        addAnotherPath = (await inquirer_1.default.prompt({
            name: 'anotherPath',
            type: 'confirm',
            message: 'Do you want to add another path?',
            default: false,
        })).anotherPath;
    } while (addAnotherPath);
    const { dependsOn, functionArns } = await findDependsOn(paths, context);
    return { paths, dependsOn, functionArns };
}
async function findDependsOn(paths, context) {
    const dependsOn = [];
    const functionArns = [];
    for (let i = 0; i < paths.length; i += 1) {
        if (paths[i].lambdaFunction && !paths[i].lambdaArn) {
            if (!dependsOn.find(func => func.resourceName === paths[i].lambdaFunction)) {
                dependsOn.push({
                    category: 'function',
                    resourceName: paths[i].lambdaFunction,
                    attributes: ['Name', 'Arn'],
                });
            }
        }
        if (!functionArns.find(func => func.lambdaFunction === paths[i].lambdaFunction)) {
            functionArns.push({
                lambdaFunction: paths[i].lambdaFunction,
                lambdaArn: paths[i].lambdaArn,
            });
        }
        if (paths[i].privacy && paths[i].privacy.userPoolGroups) {
            const userPoolGroups = Object.keys(paths[i].privacy.userPoolGroups);
            if (userPoolGroups.length > 0) {
                const authResourceName = await getAuthResourceName(context);
                if (!dependsOn.find(resource => resource.resourceName === authResourceName)) {
                    dependsOn.push({
                        category: 'auth',
                        resourceName: authResourceName,
                        attributes: ['UserPoolId'],
                    });
                }
                userPoolGroups.forEach(group => {
                    if (!dependsOn.find(resource => resource.attributes[0] === `${group}GroupRole`)) {
                        dependsOn.push({
                            category: 'auth',
                            resourceName: 'userPoolGroups',
                            attributes: [`${group}GroupRole`],
                        });
                    }
                });
            }
        }
    }
    return { dependsOn, functionArns };
}
async function getAuthResourceName(context) {
    let authResources = (await context.amplify.getResourceStatus('auth')).allResources;
    authResources = authResources.filter(resource => resource.service === 'Cognito');
    if (authResources.length === 0) {
        throw new Error('No auth resource found. Please add it using amplify add auth');
    }
    const authResourceName = authResources[0].resourceName;
    return authResourceName;
}
function functionsExist(context) {
    if (!context.amplify.getProjectDetails().amplifyMeta.function) {
        return false;
    }
    const functionResources = context.amplify.getProjectDetails().amplifyMeta.function;
    const lambdaFunctions = [];
    Object.keys(functionResources).forEach(resourceName => {
        if (functionResources[resourceName].service === FunctionServiceNameLambdaFunction) {
            lambdaFunctions.push(resourceName);
        }
    });
    if (lambdaFunctions.length === 0) {
        return false;
    }
    return true;
}
async function askLambdaSource(context, functionType, path, currentPath) {
    switch (functionType) {
        case 'arn':
            return askLambdaArn(context, currentPath);
        case 'projectFunction':
            return askLambdaFromProject(context, currentPath);
        case 'newFunction':
            return newLambdaFunction(context, path);
        default:
            throw new Error('Type not supported');
    }
}
async function newLambdaFunction(context, path) {
    context.api = {
        path,
        expressPath: rest_api_path_utils_1.formatCFNPathParamsForExpressJs(path),
        functionTemplate: 'serverless',
    };
    let params = {
        functionTemplate: {
            parameters: {
                path,
                expressPath: rest_api_path_utils_1.formatCFNPathParamsForExpressJs(path),
            },
        },
    };
    const resourceName = await context.amplify.invokePluginMethod(context, 'function', undefined, 'add', [
        context,
        'awscloudformation',
        FunctionServiceNameLambdaFunction,
        params,
    ]);
    context.print.success('Succesfully added the Lambda function locally');
    return { lambdaFunction: resourceName };
}
async function askLambdaFromProject(context, currentPath) {
    const functionResources = context.amplify.getProjectDetails().amplifyMeta.function;
    const lambdaFunctions = [];
    Object.keys(functionResources).forEach(resourceName => {
        if (functionResources[resourceName].service === FunctionServiceNameLambdaFunction) {
            lambdaFunctions.push(resourceName);
        }
    });
    const answer = await inquirer_1.default.prompt({
        name: 'lambdaFunction',
        type: 'list',
        message: 'Choose the Lambda function to invoke by this path',
        choices: lambdaFunctions,
        default: currentPath ? currentPath.lambdaFunction : lambdaFunctions[0],
    });
    return { lambdaFunction: answer.lambdaFunction };
}
async function askLambdaArn(context, currentPath) {
    const lambdaFunctions = await context.amplify.executeProviderUtils(context, 'awscloudformation', 'getLambdaFunctions');
    const lambdaOptions = lambdaFunctions.map(lambdaFunction => ({
        value: lambdaFunction.FunctionArn,
        name: `${lambdaFunction.FunctionName} (${lambdaFunction.FunctionArn})`,
    }));
    if (lambdaOptions.length === 0) {
        context.print.error('You do not have any Lambda functions configured for the selected Region');
        return null;
    }
    const lambdaCloudOptionQuestion = {
        type: 'list',
        name: 'lambdaChoice',
        message: 'Please select a Lambda function',
        choices: lambdaOptions,
        default: currentPath && currentPath.lambdaArn ? `${currentPath.lambdaArn}` : `${lambdaOptions[0].value}`,
    };
    let lambdaOption;
    while (!lambdaOption) {
        try {
            lambdaOption = await inquirer_1.default.prompt([lambdaCloudOptionQuestion]);
        }
        catch (err) {
            context.print.error('Select a Lambda Function');
        }
    }
    const lambdaCloudOptionAnswer = lambdaFunctions.find(lambda => lambda.FunctionArn === lambdaOption.lambdaChoice);
    return {
        lambdaArn: lambdaCloudOptionAnswer.FunctionArn,
        lambdaFunction: lambdaCloudOptionAnswer.FunctionName,
    };
}
async function migrate(context, projectPath, resourceName) {
    const { amplify } = context;
    const targetDir = amplify.pathManager.getBackendDirPath();
    const resourceDirPath = path.join(targetDir, category, resourceName);
    const parametersFilePath = path.join(resourceDirPath, parametersFileName);
    let parameters;
    try {
        parameters = amplify.readJsonFile(parametersFilePath);
    }
    catch (e) {
        context.print.error(`Error reading api-params.json file for ${resourceName} resource`);
        throw e;
    }
    const copyJobs = [
        {
            dir: path.join(aws_constants_1.rootAssetDir, 'cloudformation-templates'),
            template: 'apigw-cloudformation-template-default.json.ejs',
            target: `${targetDir}/${category}/${resourceName}/${resourceName}-cloudformation-template.json`,
        },
    ];
    await context.amplify.copyBatch(context, copyJobs, parameters, true, false);
    const cfnParameters = {
        authRoleName: {
            Ref: 'AuthRoleName',
        },
        unauthRoleName: {
            Ref: 'UnauthRoleName',
        },
    };
    const cfnParametersFilePath = path.join(resourceDirPath, cfnParametersFilename);
    const jsonString = JSON.stringify(cfnParameters, null, 4);
    fs.writeFileSync(cfnParametersFilePath, jsonString, 'utf8');
}
exports.migrate = migrate;
function convertToCRUD(privacy) {
    if (privacy === 'r') {
        privacy = ['/GET'];
    }
    else if (privacy === 'rw') {
        privacy = ['/POST', '/GET', '/PUT', '/PATCH', '/DELETE'];
    }
    return privacy;
}
function getIAMPolicies(resourceName, crudOptions) {
    let policy = {};
    const actions = [];
    crudOptions.forEach(crudOption => {
        switch (crudOption) {
            case 'create':
                actions.push('apigateway:POST', 'apigateway:PUT');
                break;
            case 'update':
                actions.push('apigateway:PATCH');
                break;
            case 'read':
                actions.push('apigateway:GET', 'apigateway:HEAD', 'apigateway:OPTIONS');
                break;
            case 'delete':
                actions.push('apigateway:DELETE');
                break;
            default:
                console.log(`${crudOption} not supported`);
        }
    });
    policy = {
        Effect: 'Allow',
        Action: actions,
        Resource: [
            {
                'Fn::Join': [
                    '',
                    [
                        'arn:aws:apigateway:',
                        {
                            Ref: 'AWS::Region',
                        },
                        '::/restapis/',
                        {
                            Ref: `${category}${resourceName}ApiName`,
                        },
                        '/*',
                    ],
                ],
            },
        ],
    };
    const attributes = ['ApiName', 'ApiId'];
    return { policy, attributes };
}
exports.getIAMPolicies = getIAMPolicies;
const openConsole = async (context) => {
    const amplifyMeta = amplify_cli_core_1.stateManager.getMeta();
    const categoryAmplifyMeta = amplifyMeta[category];
    const { Region } = amplifyMeta.providers.awscloudformation;
    const restApis = Object.keys(categoryAmplifyMeta).filter(resourceName => {
        const resource = categoryAmplifyMeta[resourceName];
        return (resource.output &&
            (resource.service === serviceName || (resource.service === elasticContainerServiceName && resource.apiType === 'REST')));
    });
    if (restApis) {
        let url;
        let selectedApi = restApis[0];
        if (restApis.length > 1) {
            ({ selectedApi } = await inquirer_1.default.prompt({
                type: 'list',
                name: 'selectedApi',
                choices: restApis,
                message: 'Please select the API',
            }));
        }
        const selectedResource = categoryAmplifyMeta[selectedApi];
        if (selectedResource.service === serviceName) {
            const { output: { ApiId }, } = selectedResource;
            url = `https://${Region}.console.aws.amazon.com/apigateway/home?region=${Region}#/apis/${ApiId}/resources/`;
        }
        else {
            const { output: { PipelineName, ServiceName, ClusterName }, } = selectedResource;
            const codePipeline = 'CodePipeline';
            const elasticContainer = 'ElasticContainer';
            const { selectedConsole } = await inquirer_1.default.prompt({
                name: 'selectedConsole',
                message: 'Which console you want to open',
                type: 'list',
                choices: [
                    {
                        name: 'Elastic Container Service (Deployed container status)',
                        value: elasticContainer,
                    },
                    {
                        name: 'CodePipeline (Container build status)',
                        value: codePipeline,
                    },
                ],
            });
            if (selectedConsole === elasticContainer) {
                url = `https://console.aws.amazon.com/ecs/home?region=${Region}#/clusters/${ClusterName}/services/${ServiceName}/details`;
            }
            else if (selectedConsole === codePipeline) {
                url = `https://${Region}.console.aws.amazon.com/codesuite/codepipeline/pipelines/${PipelineName}/view`;
            }
            else {
                context.print.error('Option not available');
                return;
            }
        }
        amplify_cli_core_1.open(url, { wait: false });
    }
    else {
        context.print.error('There are no REST APIs pushed to the cloud');
    }
};
exports.openConsole = openConsole;
//# sourceMappingURL=apigw-walkthrough.js.map