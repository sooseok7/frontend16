"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeResolverConfig = exports.getCfnApiArtifactHandler = void 0;
const amplify_cli_core_1 = require("amplify-cli-core");
const fs = __importStar(require("fs-extra"));
const graphql_transformer_core_1 = require("graphql-transformer-core");
const lodash_1 = __importDefault(require("lodash"));
const path = __importStar(require("path"));
const uuid_1 = __importDefault(require("uuid"));
const category_constants_1 = require("../../category-constants");
const aws_constants_1 = require("./aws-constants");
const amplify_meta_utils_1 = require("./utils/amplify-meta-utils");
const auth_config_to_app_sync_auth_type_bi_di_mapper_1 = require("./utils/auth-config-to-app-sync-auth-type-bi-di-mapper");
const print_api_key_warnings_1 = require("./utils/print-api-key-warnings");
const resolver_config_to_conflict_resolution_bi_di_mapper_1 = require("./utils/resolver-config-to-conflict-resolution-bi-di-mapper");
const FunctionServiceNameLambdaFunction = 'Lambda';
const getCfnApiArtifactHandler = (context) => {
    return new CfnApiArtifactHandler(context);
};
exports.getCfnApiArtifactHandler = getCfnApiArtifactHandler;
const resolversDirName = 'resolvers';
const stacksDirName = 'stacks';
const defaultStackName = 'CustomResources.json';
const defaultCfnParameters = (apiName) => ({
    AppSyncApiName: apiName,
    DynamoDBBillingMode: 'PAY_PER_REQUEST',
    DynamoDBEnableServerSideEncryption: false,
});
class CfnApiArtifactHandler {
    constructor(context) {
        this.createArtifacts = async (request) => {
            const existingApiName = amplify_meta_utils_1.getAppSyncResourceName(this.context.amplify.getProjectMeta());
            if (existingApiName) {
                throw new Error(`GraphQL API ${existingApiName} already exists in the project. Use 'amplify update api' to make modifications.`);
            }
            const serviceConfig = request.serviceConfiguration;
            amplify_cli_core_1.isResourceNameUnique('api', serviceConfig.apiName);
            const resourceDir = this.getResourceDir(serviceConfig.apiName);
            fs.ensureDirSync(resourceDir);
            const resolverDirectoryPath = path.join(resourceDir, resolversDirName);
            if (!fs.existsSync(resolverDirectoryPath)) {
                fs.mkdirSync(resolverDirectoryPath);
            }
            const stacksDirectoryPath = path.join(resourceDir, stacksDirName);
            if (!fs.existsSync(stacksDirectoryPath)) {
                fs.mkdirSync(stacksDirectoryPath);
                fs.copyFileSync(path.join(aws_constants_1.rootAssetDir, 'resolver-readme', 'RESOLVER_README.md'), path.join(resolverDirectoryPath, 'README.md'));
            }
            await this.updateTransformerConfigVersion(resourceDir);
            serviceConfig.conflictResolution = await this.createResolverResources(serviceConfig.conflictResolution);
            await exports.writeResolverConfig(serviceConfig.conflictResolution, resourceDir);
            fs.copyFileSync(path.join(aws_constants_1.rootAssetDir, 'cloudformation-templates', 'defaultCustomResources.json'), path.join(resourceDir, stacksDirName, defaultStackName));
            this.writeSchema(resourceDir, serviceConfig.transformSchema);
            const authConfig = this.extractAuthConfig(serviceConfig);
            await this.context.amplify.executeProviderUtils(this.context, 'awscloudformation', 'compileSchema', {
                resourceDir,
                parameters: this.getCfnParameters(serviceConfig.apiName, authConfig, resourceDir),
                authConfig,
            });
            this.context.amplify.updateamplifyMetaAfterResourceAdd(category_constants_1.category, serviceConfig.apiName, this.createAmplifyMeta(authConfig));
            return serviceConfig.apiName;
        };
        this.updateArtifacts = async (request) => {
            const updates = request.serviceModification;
            const apiName = amplify_meta_utils_1.getAppSyncResourceName(this.context.amplify.getProjectMeta());
            if (!apiName) {
                throw new Error(`No AppSync API configured in the project. Use 'amplify add api' to create an API.`);
            }
            const resourceDir = this.getResourceDir(apiName);
            if (updates.transformSchema) {
                this.writeSchema(resourceDir, updates.transformSchema);
            }
            if (updates.conflictResolution) {
                updates.conflictResolution = await this.createResolverResources(updates.conflictResolution);
                await exports.writeResolverConfig(updates.conflictResolution, resourceDir);
            }
            const authConfig = amplify_meta_utils_1.getAppSyncAuthConfig(this.context.amplify.getProjectMeta());
            const oldConfigHadApiKey = amplify_meta_utils_1.authConfigHasApiKey(authConfig);
            if (updates.defaultAuthType) {
                authConfig.defaultAuthentication = auth_config_to_app_sync_auth_type_bi_di_mapper_1.appSyncAuthTypeToAuthConfig(updates.defaultAuthType);
            }
            if (updates.additionalAuthTypes) {
                authConfig.additionalAuthenticationProviders = updates.additionalAuthTypes.map(auth_config_to_app_sync_auth_type_bi_di_mapper_1.appSyncAuthTypeToAuthConfig);
            }
            await this.context.amplify.executeProviderUtils(this.context, 'awscloudformation', 'compileSchema', {
                resourceDir,
                parameters: this.getCfnParameters(apiName, authConfig, resourceDir),
                authConfig,
            });
            this.context.amplify.updateamplifyMetaAfterResourceUpdate(category_constants_1.category, apiName, 'output', { authConfig });
            this.context.amplify.updateBackendConfigAfterResourceUpdate(category_constants_1.category, apiName, 'output', { authConfig });
            print_api_key_warnings_1.printApiKeyWarnings(this.context, oldConfigHadApiKey, amplify_meta_utils_1.authConfigHasApiKey(authConfig));
        };
        this.writeSchema = (resourceDir, schema) => {
            fs.writeFileSync(path.join(resourceDir, aws_constants_1.gqlSchemaFilename), schema);
        };
        this.getResourceDir = (apiName) => path.join(this.context.amplify.pathManager.getBackendDirPath(), category_constants_1.category, apiName);
        this.createAmplifyMeta = authConfig => ({
            service: 'AppSync',
            providerPlugin: aws_constants_1.provider,
            output: {
                authConfig,
            },
        });
        this.extractAuthConfig = (config) => ({
            defaultAuthentication: auth_config_to_app_sync_auth_type_bi_di_mapper_1.appSyncAuthTypeToAuthConfig(config.defaultAuthType),
            additionalAuthenticationProviders: (config.additionalAuthTypes || []).map(auth_config_to_app_sync_auth_type_bi_di_mapper_1.appSyncAuthTypeToAuthConfig),
        });
        this.updateTransformerConfigVersion = async (resourceDir) => {
            const localTransformerConfig = await graphql_transformer_core_1.readTransformerConfiguration(resourceDir);
            localTransformerConfig.Version = graphql_transformer_core_1.TRANSFORM_CURRENT_VERSION;
            localTransformerConfig.ElasticsearchWarning = true;
            await graphql_transformer_core_1.writeTransformerConfiguration(resourceDir, localTransformerConfig);
        };
        this.createResolverResources = async (conflictResolution = {}) => {
            const newConflictResolution = lodash_1.default.cloneDeep(conflictResolution);
            const generateLambdaIfNew = async (strat) => {
                if (strat && strat.type === 'LAMBDA' && strat.resolver.type === 'NEW') {
                    strat.resolver = {
                        type: 'EXISTING',
                        name: await this.createSyncFunction(),
                    };
                }
            };
            await generateLambdaIfNew(newConflictResolution.defaultResolutionStrategy);
            await Promise.all((newConflictResolution.perModelResolutionStrategy || [])
                .map(perModelStrat => perModelStrat.resolutionStrategy)
                .map(generateLambdaIfNew));
            return newConflictResolution;
        };
        this.getCfnParameters = (apiName, authConfig, resourceDir) => {
            const params = this.context.amplify.readJsonFile(path.join(resourceDir, aws_constants_1.cfnParametersFilename), undefined, false) || defaultCfnParameters(apiName);
            const cognitoPool = this.getCognitoUserPool(authConfig);
            if (cognitoPool) {
                params.AuthCognitoUserPoolId = cognitoPool;
            }
            else {
                delete params.AuthCognitoUserPoolId;
            }
            return params;
        };
        this.getCognitoUserPool = authConfig => {
            const additionalUserPoolProvider = (authConfig.additionalAuthenticationProviders || []).find(provider => provider.authenticationType === 'AMAZON_COGNITO_USER_POOLS');
            const defaultAuth = authConfig.defaultAuthentication || {};
            if (defaultAuth.authenticationType === 'AMAZON_COGNITO_USER_POOLS' || additionalUserPoolProvider) {
                let userPoolId;
                const configuredUserPoolName = amplify_meta_utils_1.checkIfAuthExists(this.context);
                if (authConfig.userPoolConfig) {
                    ({ userPoolId } = authConfig.userPoolConfig);
                }
                else if (additionalUserPoolProvider && additionalUserPoolProvider.userPoolConfig) {
                    ({ userPoolId } = additionalUserPoolProvider.userPoolConfig);
                }
                else if (configuredUserPoolName) {
                    userPoolId = `auth${configuredUserPoolName}`;
                }
                else {
                    throw new Error('Cannot find a configured Cognito User Pool.');
                }
                return {
                    'Fn::GetAtt': [userPoolId, 'Outputs.UserPoolId'],
                };
            }
        };
        this.createSyncFunction = async () => {
            const targetDir = this.context.amplify.pathManager.getBackendDirPath();
            const assetDir = path.normalize(path.join(aws_constants_1.rootAssetDir, 'sync-conflict-handler'));
            const [shortId] = uuid_1.default().split('-');
            const functionName = `syncConflictHandler${shortId}`;
            const functionProps = {
                functionName: `${functionName}`,
                roleName: `${functionName}LambdaRole`,
            };
            const copyJobs = [
                {
                    dir: assetDir,
                    template: 'sync-conflict-handler-index.js.ejs',
                    target: `${targetDir}/function/${functionName}/src/index.js`,
                },
                {
                    dir: assetDir,
                    template: 'sync-conflict-handler-package.json.ejs',
                    target: `${targetDir}/function/${functionName}/src/package.json`,
                },
                {
                    dir: assetDir,
                    template: 'sync-conflict-handler-template.json.ejs',
                    target: `${targetDir}/function/${functionName}/${functionName}-cloudformation-template.json`,
                },
            ];
            await this.context.amplify.copyBatch(this.context, copyJobs, functionProps, true);
            const backendConfigs = {
                service: FunctionServiceNameLambdaFunction,
                providerPlugin: aws_constants_1.provider,
                build: true,
            };
            await this.context.amplify.updateamplifyMetaAfterResourceAdd('function', functionName, backendConfigs);
            this.context.print.success(`Successfully added ${functionName} function locally`);
            return functionName + '-${env}';
        };
        this.context = context;
    }
}
const writeResolverConfig = async (conflictResolution, resourceDir) => {
    const localTransformerConfig = await graphql_transformer_core_1.readTransformerConfiguration(resourceDir);
    localTransformerConfig.ResolverConfig = resolver_config_to_conflict_resolution_bi_di_mapper_1.conflictResolutionToResolverConfig(conflictResolution);
    await graphql_transformer_core_1.writeTransformerConfiguration(resourceDir, localTransformerConfig);
};
exports.writeResolverConfig = writeResolverConfig;
//# sourceMappingURL=cfn-api-artifact-handler.js.map