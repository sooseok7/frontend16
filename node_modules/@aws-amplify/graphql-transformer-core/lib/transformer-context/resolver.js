"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransformerResolver = exports.ResolverManager = void 0;
const core_1 = require("@aws-cdk/core");
const assert_1 = __importDefault(require("assert"));
const graphql_transformer_common_1 = require("graphql-transformer-common");
const ts_dedent_1 = require("ts-dedent");
const cdk_compat_1 = require("../cdk-compat");
const SyncUtils = __importStar(require("../transformation/sync-utils"));
const NONE_DATA_SOURCE_NAME = 'NONE_DS';
class ResolverManager {
    constructor() {
        this.resolvers = new Map();
        this.generateQueryResolver = (typeName, fieldName, dataSource, requestMappingTemplate, responseMappingTemplate) => {
            return new TransformerResolver(typeName, fieldName, requestMappingTemplate, responseMappingTemplate, ['init', 'preAuth', 'auth', 'postAuth', 'preDataLoad'], ['postDataLoad', 'finish'], dataSource);
        };
        this.generateMutationResolver = (typeName, fieldName, dataSource, requestMappingTemplate, responseMappingTemplate) => {
            return new TransformerResolver(typeName, fieldName, requestMappingTemplate, responseMappingTemplate, ['init', 'preAuth', 'auth', 'postAuth', 'preUpdate'], ['postUpdate', 'finish'], dataSource);
        };
        this.generateSubscriptionResolver = (typeName, fieldName, requestMappingTemplate, responseMappingTemplate) => {
            return new TransformerResolver(typeName, fieldName, requestMappingTemplate, responseMappingTemplate, ['init', 'preAuth', 'auth', 'postAuth', 'preSubscribe'], []);
        };
        this.addResolver = (typeName, fieldName, resolver) => {
            const key = `${typeName}.${fieldName}`;
            if (this.resolvers.has(key)) {
                throw new Error(`A resolver for typeName ${typeName} fieldName: ${fieldName} already exists`);
            }
            this.resolvers.set(key, resolver);
            return resolver;
        };
        this.getResolver = (typeName, fieldName) => {
            const key = `${typeName}.${fieldName}`;
            if (this.resolvers.has(key)) {
                return this.resolvers.get(key);
            }
        };
        this.removeResolver = (typeName, fieldName) => {
            const key = `${typeName}.${fieldName}`;
            if (this.resolvers.has(key)) {
                const resolver = this.resolvers.get(key);
                this.resolvers.delete(key);
                return resolver;
            }
            throw new Error(`Resolver for typeName ${typeName} fieldName: ${fieldName} does not exists`);
        };
        this.collectResolvers = () => {
            return new Map(this.resolvers.entries());
        };
    }
}
exports.ResolverManager = ResolverManager;
class TransformerResolver {
    constructor(typeName, fieldName, requestMappingTemplate, responseMappingTemplate, requestSlots, responseSlots, datasource) {
        this.typeName = typeName;
        this.fieldName = fieldName;
        this.requestMappingTemplate = requestMappingTemplate;
        this.responseMappingTemplate = responseMappingTemplate;
        this.requestSlots = requestSlots;
        this.responseSlots = responseSlots;
        this.datasource = datasource;
        this.slotMap = new Map();
        this.mapToStack = (stack) => {
            this.stack = stack;
        };
        this.addToSlot = (slotName, requestMappingTemplate, responseMappingTemplate, dataSource) => {
            if (!this.slotNames.has(slotName)) {
                throw new Error(`Resolver is missing slot ${slotName}`);
            }
            let slotEntry;
            if (this.slotMap.has(slotName)) {
                slotEntry = this.slotMap.get(slotName);
            }
            else {
                slotEntry = [];
            }
            slotEntry.push({
                requestMappingTemplate,
                responseMappingTemplate,
                dataSource,
            });
            this.slotMap.set(slotName, slotEntry);
        };
        this.synthesize = (context, api) => {
            var _a, _b, _c, _d, _e, _f, _g;
            const stack = this.stack || context.stackManager.rootStack;
            this.ensureNoneDataSource(api);
            const requestFns = this.synthesizePipelineFunctions(stack, api, this.requestSlots);
            const responseFns = this.synthesizePipelineFunctions(stack, api, this.responseSlots);
            [this.requestMappingTemplate, this.requestMappingTemplate].map(template => this.substitueSlotInfo(template, 'main', 0));
            const dataSourceProviderFn = api.host.addAppSyncFunction(graphql_transformer_common_1.toPascalCase([this.typeName, this.fieldName, 'DataResolverFn']), this.requestMappingTemplate, this.responseMappingTemplate, ((_a = this.datasource) === null || _a === void 0 ? void 0 : _a.name) || NONE_DATA_SOURCE_NAME, stack);
            let dataSourceType = 'NONE';
            let dataSource = '';
            if (this.datasource) {
                dataSourceType = this.datasource.ds.type;
                switch (dataSourceType) {
                    case 'AMAZON_DYNAMODB':
                        if (this.datasource.ds.dynamoDbConfig && !core_1.isResolvableObject(this.datasource.ds.dynamoDbConfig)) {
                            const tableName = (_b = this.datasource.ds.dynamoDbConfig) === null || _b === void 0 ? void 0 : _b.tableName;
                            dataSource = `$util.qr($ctx.stash.put("tableName", "${tableName}"))`;
                        }
                        if (context.isProjectUsingDataStore()) {
                            const syncConfig = SyncUtils.getSyncConfig(context, this.typeName);
                            const funcConf = dataSourceProviderFn.node.children.find((it) => it.cfnResourceType === 'AWS::AppSync::FunctionConfiguration');
                            if (funcConf) {
                                funcConf.syncConfig = {
                                    conflictDetection: syncConfig.ConflictDetection,
                                    conflictHandler: syncConfig.ConflictHandler,
                                    ...(SyncUtils.isLambdaSyncConfig(syncConfig)
                                        ? {
                                            lambdaConflictHandlerConfig: {
                                                lambdaConflictHandlerArn: syncConfig.LambdaConflictHandler.lambdaArn,
                                            },
                                        }
                                        : {}),
                                };
                            }
                        }
                        break;
                    case 'AMAZON_ELASTICSEARCH':
                        if (this.datasource.ds.elasticsearchConfig && !core_1.isResolvableObject(this.datasource.ds.elasticsearchConfig)) {
                            const endpoint = (_c = this.datasource.ds.elasticsearchConfig) === null || _c === void 0 ? void 0 : _c.endpoint;
                            dataSource = `$util.qr($ctx.stash.put("endpoint", "${endpoint}"))`;
                        }
                        break;
                    case 'AWS_LAMBDA':
                        if (this.datasource.ds.lambdaConfig && !core_1.isResolvableObject(this.datasource.ds.lambdaConfig)) {
                            const lambdaFunctionArn = (_d = this.datasource.ds.lambdaConfig) === null || _d === void 0 ? void 0 : _d.lambdaFunctionArn;
                            dataSource = `$util.qr($ctx.stash.put("lambdaFunctionArn", "${lambdaFunctionArn}"))`;
                        }
                        break;
                    case 'HTTP':
                        if (this.datasource.ds.httpConfig && !core_1.isResolvableObject(this.datasource.ds.httpConfig)) {
                            const endpoint = (_e = this.datasource.ds.httpConfig) === null || _e === void 0 ? void 0 : _e.endpoint;
                            dataSource = `$util.qr($ctx.stash.put("endpoint", "${endpoint}"))`;
                        }
                        break;
                    case 'RELATIONAL_DATABASE':
                        if (this.datasource.ds.relationalDatabaseConfig &&
                            !core_1.isResolvableObject(this.datasource.ds.relationalDatabaseConfig) &&
                            !core_1.isResolvableObject((_f = this.datasource.ds.relationalDatabaseConfig) === null || _f === void 0 ? void 0 : _f.rdsHttpEndpointConfig)) {
                            const databaseName = (_g = this.datasource.ds.relationalDatabaseConfig) === null || _g === void 0 ? void 0 : _g.rdsHttpEndpointConfig.databaseName;
                            dataSource = `$util.qr($ctx.stash.metadata.put("databaseName", "${databaseName}"))`;
                        }
                        break;
                    default:
                        throw new Error('Unknow DataSource type');
                }
            }
            api.host.addResolver(this.typeName, this.fieldName, cdk_compat_1.MappingTemplate.inlineTemplateFromString(ts_dedent_1.dedent `
      $util.qr($ctx.stash.put("typeName", "${this.typeName}"))
      $util.qr($ctx.stash.put("fieldName", "${this.fieldName}"))
      $util.qr($ctx.stash.put("conditions", []))
      $util.qr($ctx.stash.put("metadata", {}))
      $util.qr($ctx.stash.metadata.put("dataSourceType", "${dataSourceType}"))
      $util.qr($ctx.stash.metadata.put("apiId", "${api.apiId}"))
      ${dataSource}
      $util.toJson({})
      `), cdk_compat_1.MappingTemplate.inlineTemplateFromString('$util.toJson($ctx.prev.result)'), undefined, [...requestFns, dataSourceProviderFn, ...responseFns].map(fn => fn.functionId), stack);
        };
        this.synthesizePipelineFunctions = (stack, api, slotsNames) => {
            const appSyncFunctions = [];
            for (let slotName of slotsNames) {
                if (this.slotMap.has(slotName)) {
                    const slotEntries = this.slotMap.get(slotName);
                    let index = 0;
                    for (let slotItem of slotEntries) {
                        const name = `${this.typeName}${this.fieldName}${slotName}${index++}Function`;
                        const { requestMappingTemplate, responseMappingTemplate, dataSource } = slotItem;
                        this.substitueSlotInfo(requestMappingTemplate, slotName, index);
                        responseMappingTemplate && this.substitueSlotInfo(responseMappingTemplate, slotName, index);
                        const fn = api.host.addAppSyncFunction(name, requestMappingTemplate, responseMappingTemplate || cdk_compat_1.MappingTemplate.inlineTemplateFromString('$util.toJson({})'), (dataSource === null || dataSource === void 0 ? void 0 : dataSource.name) || NONE_DATA_SOURCE_NAME, stack);
                        appSyncFunctions.push(fn);
                    }
                }
            }
            return appSyncFunctions;
        };
        assert_1.default(typeName, 'typeName is required');
        assert_1.default(fieldName, 'fieldName is required');
        assert_1.default(requestMappingTemplate, 'requestMappingTemplate is required');
        assert_1.default(responseMappingTemplate, 'responseMappingTemplate is required');
        this.slotNames = new Set([...requestSlots, ...responseSlots]);
    }
    substitueSlotInfo(template, slotName, index) {
        if (template instanceof cdk_compat_1.S3MappingTemplate) {
            template.substitueValues({ slotName, slotIndex: index, typeName: this.typeName, fieldName: this.fieldName });
        }
    }
    ensureNoneDataSource(api) {
        if (!api.host.hasDataSource(NONE_DATA_SOURCE_NAME)) {
            api.host.addNoneDataSource(NONE_DATA_SOURCE_NAME, {
                name: NONE_DATA_SOURCE_NAME,
                description: 'None Data Source for Pipeline functions',
            });
        }
    }
}
exports.TransformerResolver = TransformerResolver;
//# sourceMappingURL=resolver.js.map